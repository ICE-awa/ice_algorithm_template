[toc]

## ğŸ§Š's Algorithm Template

### é£Ÿç”¨å‰æ³¨æ„

è¯¥æ¨¡æ¿åº“ä¸­æ‰€æœ‰ç”¨åˆ°çš„æ•°ç»„ï¼Œé™¤äº†ç‰¹æ®Šè¯´æ˜ï¼Œä¸€èˆ¬ä¸‹æ ‡éƒ½æ˜¯**ä»1å¼€å§‹ï¼ˆ1-basedï¼‰**ï¼Œæ“ä½œåŒºé—´éƒ½æ˜¯**å·¦é—­å³é—­**çš„åŒºé—´ï¼Œæœ‰äº›æ¨¡æ¿ä½¿ç”¨äº†**autoæˆ–è€…std::functionå°è£…**ï¼Œæ˜¯**ä¸ºäº†åŒºåˆ†è¾“å…¥ä»¥åŠå‡½æ•°ä¸»å†…å®¹**ï¼Œä¸€èˆ¬ä¸»å†…å®¹éƒ½æ˜¯autoæˆ–è€…std::functioné‡Œé¢çš„å†…å®¹ï¼Œè¯·è‡ªè¡Œæ ¹æ®é¢˜ç›®æ¥è°ƒæ•´

Alphaç‰ˆæœ¬**æœ‰éƒ¨åˆ†æ¿å—æ²¡æœ‰æ•™ç¨‹**ï¼Œæœªæ¥ä¼šç»™æ¯ä¸ªæ¿å—å¢åŠ ä½¿ç”¨æ•™ç¨‹åŠåŸç†



ğŸ§Šçš„åŸºç¡€æ¨¡æ¿

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define int long long
#define awa 0
typedef long long ll;
typedef std::pair<int, int> PII;
typedef std::map<int, int> MII;

signed ICE(){

    return awa;
}

signed main(){
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    int T = 1;
    std::cin >> T;
    while(T--)ICE();
    return 0;
}
```





### æ•°å­¦

#### æ’åˆ—ç»„åˆ

##### æ’åˆ—

```cpp
template<typename T>
T perm(T n, T k){
	T res = 1;
	for(T i = 0; i < k; i++)
		res *= (n - i);
	return res;
}
```



##### ç»„åˆ

```cpp
template<typename T>
T comb(T n, T k){
	if(!k || k == n) return 1;
	k = std::min(k, n - k);
	T res = 1;
	for(T i = 1; i <= k; i++)
		res = res * (n - k + i) / i;
	return res;
}
```



### æ•°è®º

#### åŠ æ€§å‡½æ•°å’Œå®Œå…¨åŠ æ€§å‡½æ•°

**åŠ æ€§å‡½æ•°**

åœ¨æ•°è®ºä¸­ï¼Œè‹¥å‡½æ•° $f(n)$ æ»¡è¶³ $f(1)=0$ ï¼Œä¸” $f(xy)=f(x)+f(y)$ å¯¹**ä»»æ„äº’è´¨**çš„ $x,y \in N^*$ éƒ½æˆç«‹ï¼Œåˆ™ $f(n)$ ä¸º**åŠ æ€§å‡½æ•°**



**å®Œå…¨åŠ æ€§å‡½æ•°**

åœ¨æ•°è®ºä¸­ï¼Œè‹¥å‡½æ•° $f(n)$ æ»¡è¶³ $f(1)=0$ ï¼Œä¸” $f(xy)=f(x)+f(y)$ å¯¹**ä»»æ„**çš„ $x,y \in N^*$ éƒ½æˆç«‹ï¼Œåˆ™ $f(n)$ ä¸º**å®Œå…¨åŠ æ€§å‡½æ•°**



**æ€§è´¨**

å¯¹æ­£æ•´æ•° $x$ ï¼Œè®¾å…¶å”¯ä¸€è´¨å› æ•°åˆ†è§£ä¸º $x=\Pi p_i^{k_i}$ ï¼Œå…¶ä¸­ $p_i$ ä¸ºè´¨æ•°

> å³ä»»ä½•æ­£æ•´æ•° $x$ éƒ½å¯ä»¥å”¯ä¸€åœ°åˆ†è§£ä¸ºè‹¥å¹²è´¨æ•°çš„å¹‚æ¬¡ä¹˜ç§¯ï¼Œä¾‹å¦‚ï¼š
>
> $12 = 2^2 * 3^1$
>
> $30 = 2^1 * 3^1 * 5^1$

è‹¥ $F(x)$ ä¸º**åŠ æ€§å‡½æ•°**ï¼Œåˆ™æœ‰ $F(x) = \Sigma F(p_i^{k_i})$

è‹¥ $F(x)$ ä¸º**å®Œå…¨åŠ æ€§å‡½æ•°**ï¼Œåˆ™æœ‰ $F(x) = \Sigma F(p_i^{k_i}) = \Sigma F(p_i) * k_i$



<span id="jixinghanshu"></span>

#### ç§¯æ€§å‡½æ•°ä¸å®Œå…¨ç§¯æ€§å‡½æ•°

**ç§¯æ€§å‡½æ•°**

åœ¨æ•°è®ºä¸­ï¼Œè‹¥å‡½æ•° $f(n)$ æ»¡è¶³ $f(1)=1$ ï¼Œä¸” $f(xy)=f(x)f(y)$ å¯¹**ä»»æ„äº’è´¨**çš„ $x,y \in N^*$ éƒ½æˆç«‹ï¼Œåˆ™ $f(n)$ ä¸º**ç§¯æ€§å‡½æ•°**



**å®Œå…¨ç§¯æ€§å‡½æ•°**

åœ¨æ•°è®ºä¸­ï¼Œè‹¥å‡½æ•° $f(n)$ æ»¡è¶³ $f(1)=1$ ï¼Œä¸” $f(xy)=f(x)f(y)$ å¯¹**ä»»æ„**çš„ $x,y \in N^*$ éƒ½æˆç«‹ï¼Œåˆ™ $f(n)$ ä¸º**å®Œå…¨ç§¯æ€§å‡½æ•°**



**æ€§è´¨**

è‹¥ $f(x)$ å’Œ $g(x)$ å‡ä¸ºç§¯æ€§å‡½æ•°ï¼Œåˆ™ä»¥ä¸‹å‡½æ•°ä¹Ÿä¸ºç§¯æ€§å‡½æ•°
$$
h(x) = f(x^p) \\
h(x) = f^p(x) \\
h(x) = f(x)g(x) \\
h(x) = \Sigma_{d|x} f(d)g(\frac{x}{d})
$$
å¯¹æ­£æ•´æ•° $x$ ï¼Œè®¾å…¶å”¯ä¸€è´¨å› æ•°åˆ†è§£ä¸º $x=\Pi p_i^{k_i}$ ï¼Œå…¶ä¸­ $p_i$ ä¸ºè´¨æ•°ã€‚

> å³ä»»ä½•æ­£æ•´æ•° $x$ éƒ½å¯ä»¥å”¯ä¸€åœ°åˆ†è§£ä¸ºè‹¥å¹²è´¨æ•°çš„å¹‚æ¬¡ä¹˜ç§¯ï¼Œä¾‹å¦‚ï¼š
>
> $12 = 2^2 * 3^1$
>
> $30 = 2^1 * 3^1 * 5^1$

è‹¥ $F(x)$ ä¸º**ç§¯æ€§å‡½æ•°**ï¼Œåˆ™æœ‰ $F(x) = \Pi F(p_i^{k_i})$ ã€‚

è‹¥ $F(x)$ ä¸º**å®Œå…¨ç§¯æ€§å‡½æ•°**ï¼Œåˆ™æœ‰ $F(x) = \Pi F(p_i^{k_i}) = \Pi F(p_i)^{k_i}$



#### è´¹é©¬å°å®šç†

**å®šä¹‰**

è‹¥ $p$ ä¸ºç´ æ•°ï¼Œ $gcd(a, p) = 1$ ï¼Œåˆ™ $a^{p-1} \equiv 1 \pmod p$

å¯¹äºä»»æ„æ•´æ•° $a$ ï¼Œéƒ½æœ‰ $a^p \equiv a\pmod p$

è¯æ˜è§[è´¹é©¬å°å®šç†](https://oi-wiki.org/math/number-theory/fermat/)



#### æ¬§æ‹‰å‡½æ•°

**å®šä¹‰**

æ¬§æ‹‰å‡½æ•°ï¼Œå³ $\varphi(n)$ ï¼Œè¡¨ç¤ºçš„æ˜¯å°äºç­‰äº $n$ å’Œ $n$ äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚

ä¾‹å¦‚ $\varphi(1)=1$ ã€‚

å½“ $n$ æ˜¯è´¨æ•°çš„æ—¶å€™ï¼Œæ˜¾ç„¶æœ‰ $\varphi(n) = n - 1$



**æ€§è´¨**

* æ¬§æ‹‰å‡½æ•°æ˜¯**[ç§¯æ€§å‡½æ•°](#jixinghanshu)**

â€‹	å³å¯¹ä»»æ„æ»¡è¶³ $gcd(a,b) = 1$ çš„æ•´æ•° $a, b$ ï¼Œéƒ½æœ‰ $\varphi(ab) = \varphi(a)\varphi(b)$

â€‹	ç‰¹åˆ«çš„ï¼Œå½“ $n$ æ˜¯å¥‡æ•°æ—¶ $\varphi(2n) = \varphi(n)$

* $n = \Sigma_{d|n} \varphi(d)$

  > è¿™ä¸ªç»“è®ºçš„æ„æ€æ˜¯ï¼Œæ­£æ•´æ•°nç­‰äºå®ƒçš„æ‰€æœ‰æ­£å› æ•°dçš„æ¬§æ‹‰å‡½æ•°å€¼$\varphi(d)$ä¹‹å’Œ
  > å…¶ä¸­$d|n$è¡¨ç¤º$d$æ˜¯$n$çš„æ­£å› æ•°ï¼ˆå³$d$èƒ½æ•´é™¤$n$ï¼‰
  >
  > ä¾‹å¦‚n=6æ—¶ï¼Œd=1, 2, 3, 6

* è‹¥ $n=p^k$ ï¼Œå…¶ä¸­ $p$ æ˜¯è´¨æ•°ï¼Œé‚£ä¹ˆ $\varphi(n) = p^k - p^{k-1}$

* ç”±å”¯ä¸€åˆ†è§£å®šç†ï¼Œè®¾ $n=\Pi_{i=1}^s p_i^{k_i}$ ï¼Œå…¶ä¸­ $p_i$ æ˜¯è´¨æ•°ï¼Œæœ‰ $\varphi(n) = n * \Pi_{i=1}^s \frac{p_i - 1}{p_i}$

* å¯¹ä»»æ„ä¸å…¨ä¸º0çš„æ•´æ•° $m,n, \varphi(mn) \varphi(gcd(m,n)) = \varphi(m) \varphi(n) gcd(m, n)$



**ä»£ç å®ç°**

```cpp
auto euler_phi(int x) -> int{
  int res = x;
  for(int i = 2; i * i <= x; i++)
    if(x % i == 0){
   		res = res / i * (i - 1);
      while (x % i == 0) x /= i;
    }
 	if(x > 1) res = res / x * (x - 1);
  return res;
};
```



##### æ¬§æ‹‰åæ¼”

å¸¸å¸¸ç”¨äºåŒ–ç®€ä¸€åˆ—æœ€å¤§å…¬çº¦æ•°çš„å’Œ

åœ¨ç»“è®º $n = \Sigma_{d|n} \varphi(d)$ ä¸­å¸¦å…¥ $n=gcd(a,b)$ ï¼Œåˆ™æœ‰

$gcd(a, b) = \Sigma_{d|gcd(a,b)} \varphi(d) = \Sigma[d|a][d|b]\varphi(d)$

> å…¶ä¸­ï¼Œ$[]$ç§°ä¸ºlversonæ‹¬å·ï¼Œåªæœ‰å½“å‘½é¢˜ $P$ ä¸ºçœŸæ—¶ $[P]$ å–å€¼ä¸º1ï¼Œå¦åˆ™å–0ã€‚

å¯¹ä¸Šå¼æ±‚å’Œï¼Œå°±å¯ä»¥å¾—åˆ°
$$
\Sigma_{i=1}^n gcd(i, n) = \Sigma_d \Sigma_{i=1}^n [d|i][d|n]\varphi(d) = \Sigma_d \lfloor \frac{n}{d} \rfloor \varphi(d)
$$
è¿™é‡Œå…³é”®çš„æ˜¯è§‚å¯Ÿ $\Sigma_{i=1}^n[d|i] = \lfloor \frac{n}{d} \rfloor$ ï¼Œå³åœ¨ $1$ å’Œ $n$ ä¹‹é—´èƒ½å¤Ÿè¢« $d$ æ•´é™¤çš„ $i$ çš„ä¸ªæ•°æ˜¯ $\lfloor \frac{n}{d} \rfloor$

åˆ©ç”¨è¿™ä¸ªå¼å­å°±å¯ä»¥éå†çº¦æ•°æ±‚å’Œäº†ã€‚éœ€è¦å¤šç»„æ•°æ®çš„æ—¶å€™ï¼Œå¯ä»¥é¢„å¤„ç†æ¬§æ‹‰å‡½æ•°çš„å‰ç¼€å’Œï¼Œåˆ©ç”¨æ•°è®ºåˆ†å—æŸ¥è¯¢ã€‚

> **ä¾‹å­**
>
> ç»™å®š $n \leq 100000$ ï¼Œæ±‚
> $$
> \Sigma_{i=1}^n \Sigma_{j=1}^n gcd(i, j)
> $$
> ä»¿ç…§ä¸Šè¿°çš„æ¨å¯¼ï¼Œå¯ä»¥å¾—å‡º
> $$
> \Sigma_{i=1}^n \Sigma_{j=1}^n gcd(i, j) = \Sigma_{d=1}^n \lfloor \frac{n}{d} \rfloor ^2 \varphi(d)
> $$
> å…¶ä¸­ $\lfloor \frac{n}{k} \rfloor ^2$ è¡¨ç¤º$k$çš„å€æ•°å¯¹ $(i, j)$ çš„æ•°é‡
>
> æ­¤æ—¶åªéœ€è¦ä½¿ç”¨[çº¿æ€§ç­›ï¼ˆæ¬§æ‹‰ç­›ï¼‰](#eular_shai)ä» $1$ éå†åˆ° $n$ æ±‚æ¬§æ‹‰å‡½æ•°ï¼Œå³å¯ä»¥ $O(n)$ å¾—åˆ°ç­”æ¡ˆ
>
> ```cpp
> std::vector<int> vis(n + 5), prime, phi(n + 5);
> phi[1] = 1;
> auto euler_phi = [&](int n) -> void{
>   for(int i = 2;i <= n;i++){
>     if(!vis[i]){
>       prime.push_back(i);
>       phi[i] = i - 1;
>     }
>     for(auto j : prime){
>       if(i * j > n)break;
>       vis[i * j] = true;
>       if(i % j == 0){
>         phi[i * j] = phi[i] * j;
>         break;
>       }else phi[i * j] = phi[i] * (j - 1);
>     }
>   }
> };
> euler_phi(n);
> int sum = 0;
> for(int d = 1; d <= n; d++){
>   int k = n / d;
>   sum += phi[d] * k * k;
> }
> ```



#### æ¬§æ‹‰å®šç†

è‹¥ $gcd(a, m) = 1$ ï¼Œåˆ™ $a^{\varphi(m)} \equiv 1 \pmod m$



#### æ‰©å±•æ¬§æ‹‰å®šç†

$ a^b\equiv \begin{cases} a^{b\bmod\varphi(m)},\,&\gcd(a,\,m)=1\\ a^b,&\gcd(a,\,m)\ne1,\,b<\varphi(m)\\ a^{b\bmod\varphi(m)+\varphi(m)},&\gcd(a,\,m)\ne1,\,b\ge\varphi(m) \end{cases} \pmod m $



#### ç´ æ•°

##### åˆ¤æ–­ç´ æ•°

```cpp
auto is_prime = [&](int x) -> bool{
  if(x < 2)return false;
  for(int i = 2;i * i <= x;i++)
    if(x % i == 0)return false;
 	return true;
};
```



<span id="eular_shai"></span>

##### æ¬§æ‹‰ç­›

ç­›å‡ºç´ æ•°çš„æ¬§æ‹‰ç­›ï¼š

```cpp
std::vector<int> vis(n + 5), prime;
auto euler = [&](int n) -> void{
  for(int i = 2;i <= n;i++){
    if(!vis[i])prime.push_back(i);
    for(auto j : prime){
      if(j * i > n)break;
      vis[j * i] = true;
      if(i % j == 0)break;
    }
  }
};
```

> è‹¥vis[x] = falseï¼Œåˆ™xä¸ºç´ æ•°ï¼Œprimeæ•°ç»„æ˜¯æŒ‰ç…§ä»å°åˆ°å¤§æ’åºçš„ç´ æ•°

æ±‚å‡ºæ¬§æ‹‰å‡½æ•°å€¼çš„æ¬§æ‹‰ç­›ï¼š

```cpp
std::vector<int> vis(n + 5), prime, phi(n + 5);
phi[1] = 1;
auto euler_phi = [&](int n) -> void{
  for(int i = 2;i <= n;i++){
    if(!vis[i]){
      prime.push_back(i);
      phi[i] = i - 1;
    }
    for(auto j : prime){
      if(i * j > n)break;
      vis[i * j] = true;
      if(i % j == 0){
        phi[i * j] = phi[i] * j;
        break;
      }else phi[i * j] = phi[i] * (j - 1);
    }
  }
};
```



#### min_25ç­›(ğŸ˜ƒğŸ˜­ğŸ˜ƒğŸ˜­)

> å…³äº(ğŸ˜ƒğŸ˜­ğŸ˜ƒğŸ˜­)è¿™ä¸ªæ¢—çš„æ¥æºå¯ä»¥å»çœ‹24å¹´å¹¿ä¸œçœèµ›ï¼Œå¤§è‡´å°±æ˜¯THUå‡ºé¢˜ï¼Œç”¨è¿™ä¸ªå½“ä½œç­¾åˆ°é¢˜
>
> ä¾‹é¢˜ï¼š[P5325 ã€æ¨¡æ¿ã€‘Min_25 ç­›](https://www.luogu.com.cn/problem/P5325) **é»‘é¢˜**ğŸ˜±

**æ•™ç¨‹TODO**



min_25ç­›å¯ä»¥åœ¨$O(\frac{n^{\frac{3}{4}}}{log \ n})$çš„æ—¶é—´å¤æ‚åº¦ä¸‹è§£å†³[ç§¯æ€§å‡½æ•°](#jixinghanshu)çš„å‰ç¼€å’Œé—®é¢˜



**æ¨¡æ¿**





#### å¿«é€Ÿå¹‚

```cpp
/**
	* @param base åº•æ•°
	* @param exp æŒ‡æ•°(>=0)
	* @param MOD æ¨¡æ•°ï¼ˆå¯é€‰ï¼‰
	* @return (base^exp) % MODï¼ˆå½“mod!=0æ—¶ï¼‰
*/
auto qpow = [&](int base, int exp, int MOD = 0) -> int{
	int res = 1;
	if(exp == 0)return 1;
	while(exp){
		if(exp & 1)
			if(MOD)res = res * base % MOD;
			else res = res * base;
		if(MOD)base = base * base % MOD;
		else base = base * base;
		exp >>= 1;
	}
	return MOD ? res % MOD : res;
};
```

> æœ‰ä¸¤ç§ä½¿ç”¨æ–¹æ³•ï¼Œç¬¬ä¸€ç§ç›´æ¥ä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼ˆåº•æ•°ï¼ŒæŒ‡æ•°ï¼‰ï¼Œä¾‹å¦‚ $2^{10}$ å¯ä½¿ç”¨qpow(2, 10)
>
> ç¬¬äºŒç§ä¼ å…¥ä¸‰ä¸ªå‚æ•°ï¼ˆåº•æ•°ï¼ŒæŒ‡æ•°ï¼Œæ¨¡æ•°ï¼‰ï¼Œä¾‹å¦‚è¦æ±‚ $a^b\ mod\ c$ åˆ™å¯ä»¥ä½¿ç”¨qpow(a, b, c)
>
> æ—¶é—´å¤æ‚åº¦ä¸º $O(log(exp))$



### è®¡ç®—å‡ ä½•

#### æ‰«æçº¿

![æ‰«æçº¿](/Volumes/ICE/markdown/img/æ‰«æçº¿.svg)

> æ‰«æçº¿çš„æ€è·¯ä¸ºï¼Œå°†éœ€è¦æ“ä½œçš„çŸ©é˜µä»¥yè½´å‡åºæ’åºï¼Œç„¶åç”¨[çº¿æ®µæ ‘](#SegmentTree)ç»Ÿè®¡åŒºé—´
>
> æ¯ä¸€ä¸ªæ“ä½œå¯ä»¥è¢«æŠ½è±¡æˆä¸€ä¸ªstd::array<int, 4>, ä»£è¡¨y, x_begin, x_end, type
>
> è‹¥typeä¸º1ï¼Œè¡¨ç¤ºè¿™æ˜¯èµ·å§‹çº¿æ®µï¼Œtypeä¸º-1è¡¨ç¤ºä¸ºæœ«å°¾çº¿æ®µ
>
> é‚£ä¹ˆå¯¹äºæ¯ä¸ªçŸ©é˜µï¼Œåªéœ€è¦æ”¾å…¥ä¸¤ä¸ªæ“ä½œ
>
> 1. (y_begin, x_begin, x_end, 1)
>
> 2. (y_end, x_begin, x_end, -1)
>
> ä¾‹é¢˜ï¼š[P1884 [USACO12FEB] Overplanting S](https://www.luogu.com.cn/problem/P1884)

```cpp
std::vector<std::array<int, 4>> a;
std::vector<int> x;
for(int i = 1;i <= n;i++){
  int x_begin, x_end, y_begin, y_end;
  std::cin >> x_begin >> x_end >> y_begin >> y_end;
  a.push_back({y_begin, x_begin, x_end, 1});
  a.push_back({y_end, x_begin, x_end, -1});
  x.push_back(x_begin);
  x.push_back(x_end);
}
std::sort(a.begin(), a.end(), [&](const std::array<int, 4> &xx, const std::array<int, 4> &yy) -> bool{
  if(xx[0] != yy[0])return xx[0] < yy[0];//å°†yè½´å‡åºæ’åº
  return xx[3] < yy[3];//å¦‚æœyè½´ç›¸åŒï¼Œå…ˆå°†-1æ”¾åœ¨å‰é¢
});
SegmentTree st(x);
int ans = 0, last = a[0][0];
for(int i = 0;i < a.size();i++){
  auto [y, x1, x2, t] = a[i];
  if(i)ans += (y - last) * st.getlen();
  st.apply(x1, x2, t);
  last = y
}
std::cout << ans << endl;
```

> ä¸Šè¿°ä»£ç ä¸­çš„çº¿æ®µæ ‘è‡ªå¸¦ç¦»æ•£ï¼Œä»£ç å¦‚ä¸‹ï¼š
>
> ```cpp
> class SegmentTree{
> private:
> 	std::vector<int> xs;
> 	std::vector<int> cover;
> 	std::vector<int> len;
> 	int sz;
> 	void build(int k, int l, int r){
> 		if(l == r){
> 			len[k] = 0;
> 			return ;
> 		}
> 		int mid = (l + r) >> 1;
> 		build(k << 1, l, mid);
> 		build(k << 1 | 1, mid + 1, r);
> 		pushup(k, l, r);
> 	}
> 
> 	void pushup(int k, int l, int r){
> 		if(cover[k])len[k] = xs[r + 1] - xs[l];
> 		else{
> 			if(l == r)len[k] = 0;
> 			else len[k] = len[k << 1] + len[k << 1 | 1];
> 		}
> 	}
> 
> 	void update(int k, int l, int r, int x, int y, int val){
> 		if(x > r || y < l) return ;
> 		if(x <= l && r <= y){
> 			cover[k] += val;
> 			pushup(k, l, r);
> 			return ;
> 		}
> 		int mid = (l + r) >> 1;
> 		update(k << 1, l, mid, x, y, val);
> 		update(k << 1 | 1, mid + 1, r, x, y, val);
> 		pushup(k, l, r);
> 	}
> public:
> 	SegmentTree(std::vector<int> &x){
> 		std::sort(x.begin(), x.end());
> 		x.erase(std::unique(x.begin(), x.end()), x.end());
> 		sz = x.size();
> 		xs.resize(sz + 1);
> 		for(int i = 0;i < sz;i++)
> 			xs[i + 1] = x[i];
> 		cover.resize((sz + 1) << 2, 0);
> 		len.resize((sz + 1) << 2, 0);
> 		build(1, 1, sz);
> 	}
> 
> 	void apply(int x1, int x2, int val){
> 		int l = std::lower_bound(xs.begin() + 1, xs.end(), x1) - xs.begin();
> 		int r = std::lower_bound(xs.begin() + 1, xs.end(), x2) - xs.begin();
> 		if(l >= r) return ;
> 		update(1, 1, sz, l, r - 1, val);
> 	}
> 
> 	int getlen(){
> 		return len[1];
> 	}
> };
> ```



### å­—ç¬¦ä¸²

#### KMP

> æ—¶é—´å¤æ‚åº¦ä¸º$O(m+n)$ï¼Œç”¨äºå­—ç¬¦ä¸²åŒ¹é…ï¼Œ[ç‚¹æˆ‘è·³è½¬åˆ°æ¨¡æ¿](#KMP)

**æ•™ç¨‹**

æœ€æœ´ç´ çš„å•æ¨¡å¼å­—ç¬¦ä¸²åŒ¹é…å¤§æ¦‚æ˜¯æšä¸¾æ¯ä¸€ä¸ªæ–‡æœ¬ä¸²å…ƒç´ ï¼Œç„¶åä»è¿™ä¸€ä½å¼€å§‹ä¸æ–­å‘åæ¯”è¾ƒï¼Œæ¯æ¬¡æ¯”è¾ƒå¤±è´¥ä¹‹åéƒ½è¦ä»å¤´å¼€å§‹æ¯”å¯¹ï¼ŒæœŸæœ›æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n+m)$ ï¼Œä½†è‹¥æ˜¯æ¯ä¸ªå­—ç¬¦ä¸²çš„æœ€åä¸€ä½æ— æ³•è¢«åŒ¹é…åˆ°ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å°±ä¼šå˜æˆ $O(nm)$

KMPç®—æ³•çš„ç²¾é«“åœ¨äºï¼Œæ¯æ¬¡å¤±é…ä¹‹åï¼Œä¸ä¼šä»å¤´é‡æ–°æšä¸¾ï¼Œè€Œæ˜¯æ ¹æ®å·²çŸ¥æ•°æ®ä»æŸä¸ªç‰¹å®šä½ç½®å¼€å§‹åŒ¹é…ã€‚å¯¹äºæ¨¡å¼ä¸²çš„æ¯ä¸€ä½ï¼Œéƒ½æœ‰**å”¯ä¸€**çš„â€œç‰¹å®šå˜åŒ–ä½ç½®â€ï¼Œç”¨äºå¸®åŠ©æˆ‘ä»¬åˆ©ç”¨å·²æœ‰çš„æ•°æ®ä¸ç”¨ä»å¤´åŒ¹é…ï¼Œä»è€ŒèŠ‚çº¦æ—¶é—´ã€‚

äº†è§£KMPç®—æ³•å‰ï¼Œéœ€è¦äº†è§£ä»¥ä¸‹å®šä¹‰ï¼š

**æ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²**

æ¨¡å¼ä¸²å€¼å¾—æ˜¯éœ€è¦è¢«åŒ¹é…çš„ä¸²

æ–‡æœ¬ä¸²æ˜¯å€¼åŒ¹é…çš„æ¨¡æ¿ä¸²

ä¾‹å¦‚æˆ‘æƒ³è¦åˆ¤æ–­abcabæ˜¯å¦åœ¨abcacababcabä¸­ï¼Œåœ¨çš„è¯åœ¨ç¬¬å‡ ä½

abcabå°±ä¸ºæ¨¡å¼ä¸²

abcacababcabå°±ä¸ºæ–‡æœ¬ä¸²



**ä»€ä¹ˆæ˜¯æœ€é•¿å…¬å…±å‰åç¼€**

1. å­—ç¬¦ä¸²çš„å‰ç¼€æ˜¯æŒ‡**ä¸åŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦**çš„**æ‰€æœ‰ä»¥ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼ˆindex=0ï¼‰å¼€å¤´çš„è¿ç»­å­ä¸²**
	> ä¾‹å¦‚å¯¹äºå­—ç¬¦ä¸²"ABABA"ï¼Œå…¶å‰ç¼€æœ‰"A"ï¼Œ"AB"ï¼Œ"ABA"ï¼Œ"ABAB"
	
2. å­—ç¬¦ä¸²çš„åç¼€æ˜¯æŒ‡**ä¸åŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦**çš„**æ‰€æœ‰ä»¥æœ€åä¸€ä¸ªå­—ç¬¦ç»“å°¾çš„è¿ç»­å­ä¸²**
	> ä¾‹å¦‚å¯¹äºå­—ç¬¦ä¸²"ABABA"ï¼Œå…¶åç¼€æœ‰"BABA"ï¼Œ"ABA"ï¼Œ"BA"ï¼Œ"A"
	
3. å…¬å…±å‰åç¼€ï¼šä¸€ä¸ªå­—ç¬¦ä¸²çš„**æ‰€æœ‰å‰ç¼€è¿ç»­å­ä¸²**å’Œ**æ‰€æœ‰åç¼€è¿ç»­å­ä¸²**ä¸­ç›¸ç­‰çš„å­ä¸²
	> ä¾‹å¦‚å¯¹äºå­—ç¬¦ä¸²"ABABA"
	>
	> * å‰ç¼€æœ‰ï¼š**"A"**ï¼Œ"AB"ï¼Œ**"ABA"**ï¼Œ"ABAB"
	> * åç¼€æœ‰ï¼š"BABA"ï¼Œ**"ABA"**ï¼Œ"BA"ï¼Œ**"A"**
	>
	> å› æ­¤å…¬å…±å‰åç¼€æœ‰ï¼š**"A"**ï¼Œ**"ABA"**
	
4. æœ€é•¿å…¬å…±å‰åç¼€ï¼šæ‰€æœ‰**å…¬å…±å‰åç¼€**çš„**é•¿åº¦æœ€é•¿**çš„é‚£ä¸ªå­ä¸²
	> ä¾‹å¦‚å¯¹äºå­—ç¬¦ä¸²"ABABA"ï¼Œå…¬å…±å‰åç¼€æœ‰**"A"**ï¼Œ**"ABA"**
	>
	> é‚£ä¹ˆæœ€é•¿å…¬å…±å‰åç¼€å°±æ˜¯**"ABA"**



**ä»€ä¹ˆæ˜¯éƒ¨åˆ†åŒ¹é…è¡¨Next**

å¯¹äºå­—ç¬¦ä¸²ï¼Œä»**ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹çš„æ¯ä¸ªå­ä¸²** çš„ **æœ€åä¸€ä¸ªå­—ç¬¦** ä¸ **è¯¥å­ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦** å¯¹åº”çš„å…³ç³»è¡¨æ ¼ç§°ä¸º**éƒ¨åˆ†åŒ¹é…è¡¨**ã€‚è¿™ä¸ªè¡¨ä»¥intæ•°ç»„æ–¹å¼å­˜å‚¨ã€‚

è¿™ä¸€æ­¥æœ€å·§å¦™çš„æ˜¯åœ¨**éå†æ–‡æœ¬ä¸²**çš„è¿‡ç¨‹ä¸­ï¼Œå°†**åé¢çš„ä¸€æ®µå­ä¸²** å’Œ **è¿™æ®µå­ä¸²** åœ¨ **å‰é¢å‡ºç°è¿‡çš„æœ€é•¿åŒ¹é…çš„æœ€åä½ç½®** å­˜å‚¨åˆ°nextæ•°ç»„ä¸­ï¼Œå¯ä»¥ç»“åˆä¸‹é¢ä¾‹å­è¿›è¡Œç†è§£ï¼š

> ä¾‹å¦‚å¯¹äºå­—ç¬¦ä¸²"ABCABD"
>
> * å­ä¸²"A"ï¼šæœ€åä¸€ä¸ªå­—ç¬¦æ˜¯Aï¼Œè¯¥å­ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€é•¿åº¦æ˜¯0ï¼Œå¯¹åº”å…³ç³»æ˜¯A - 0
>
> * å­ä¸²"AB"ï¼šæœ€åä¸€ä¸ªå­—ç¬¦æ˜¯Bï¼Œè¯¥å­ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€é•¿åº¦æ˜¯0ï¼Œå¯¹åº”å…³ç³»æ˜¯B - 0
>
> * å­ä¸²"ABC"ï¼šæœ€åä¸€ä¸ªå­—ç¬¦æ˜¯Cï¼Œè¯¥å­ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€é•¿åº¦æ˜¯0ï¼Œå¯¹åº”å…³ç³»æ˜¯C - 0
>
> * å­ä¸²"ABCA"ï¼šæœ€åä¸€ä¸ªå­—ç¬¦æ˜¯Aï¼Œè¯¥å­ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€é•¿åº¦æ˜¯1ï¼Œå¯¹åº”å…³ç³»æ˜¯A - 1
>
>   > å‰ç¼€æœ‰ï¼š"A", "AB", "ABC"
>   >
>   > åç¼€æœ‰ï¼š"BCA", "CA", "A"
>   >
>   > åˆ™æœ€é•¿å…¬å…±å‰åç¼€ä¸º"A"
>   >
>   > æ­¤å¤„ä½¿å¾—æœ€åå‡ºç°çš„**A**è·Ÿä¹‹å‰çš„**A**çš„ä½ç½®å­˜å‚¨åˆ°äº†nextæ•°ç»„é‡Œï¼Œå³
>   >
>   > **A**BC**A**
>
> * å­ä¸²"ABCAB"ï¼šæœ€åä¸€ä¸ªå­—ç¬¦æ˜¯Bï¼Œè¯¥å­ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€é•¿åº¦æ˜¯2ï¼Œå¯¹åº”å…³ç³»æ˜¯B - 2
>
>   > å‰ç¼€æœ‰ï¼š"A", "AB", "ABC", "ABCA"
>   >
>   > åç¼€æœ‰ï¼š"BCAB", "CAB", "AB", "B"
>   >
>   > åˆ™æœ€é•¿å…¬å…±å‰åç¼€ä¸º"AB"
>   >
>   > æ­¤å¤„ä½¿å¾—æœ€åå‡ºç°çš„**AB**è·Ÿä¹‹å‰çš„**AB**çš„ä½ç½®å­˜å‚¨åˆ°äº†nextæ•°ç»„é‡Œï¼Œå³
>   >
>   > **AB**C**AB**
>
> * å­ä¸²"ABCABD"ï¼šæœ€åä¸€ä¸ªå­—ç¬¦æ˜¯Dï¼Œè¯¥å­ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€é•¿åº¦æ˜¯0ï¼Œå¯¹åº”å…³ç³»æ˜¯D - 0
>
> ç»¼ä¸Šï¼Œæ­¤å­—ç¬¦ä¸²çš„éƒ¨åˆ†åŒ¹é…è¡¨ä¸ºï¼š
>
> |  A   |  B   |  C   |  A   |  B   |  D   |
> | :--: | :--: | :--: | :--: | :--: | :--: |
> |  0   |  0   |  0   |  1   |  2   |  0   |
>
> å¯¹åº”çš„nextæ•°ç»„å°±æ˜¯next = {0, 0, 0, 1, 2, 0}**ï¼ˆ0-basedï¼‰**

æ±‚éƒ¨åˆ†åŒ¹é…è¡¨Nextä»£ç å¦‚ä¸‹ï¼š

```cpp
int len1 = s1.size(), len2 = s2.size();
int j = 0;
for(int i = 1; i < len2; i++){//æ­¤å¤„iä»1å¼€å§‹ï¼Œæ˜¯å› ä¸ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸å­˜åœ¨æœ€é•¿å…¬å…±å‰åç¼€
  while(j > 0 && s2[i] != s2[j])j = nxt[j - 1];
  if(s2[i] == s2[j]) j++;
  nxt[i] = j;
}
```

> ä»£ç éƒ¨åˆ†è§£é‡Šï¼š
>
> forå¾ªç¯å°±æ˜¯éå†æ•´ä¸ª$s_2$ï¼Œæ³¨æ„è¿™é‡Œçš„$s_2$ä»£è¡¨çš„æ˜¯**æ¨¡å¼ä¸²**
>
> å†…å±‚çš„whileå¾ªç¯ï¼Œå¦‚æœ$j$æ­¤æ—¶å¤§äº0ï¼Œå¹¶ä¸”$s_2[i]$ä¸$s_2[j]$ä¸åŒ¹é…ï¼Œé‚£ä¹ˆå°±è¿›è¡Œå›æº¯($j=nxt[j-1]$)
>
> å¦‚æœæ­¤æ—¶$s_2[i]$ç­‰äº$s_2[j]$ï¼Œåˆ™$j$+1
>
> æ­¤æ—¶å†å°†$nxt[j]$èµ‹å€¼ä¸º$j$ï¼Œä¹Ÿå°±æ˜¯æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦
>
> > ä¾‹å¦‚å¯¹äºå­ä¸²"ABCABD"ï¼Œæ­¤æ—¶$i=1$ï¼Œ$j=0$
> >
> > å› ä¸º$s_2[i] \neq s_2[j]\ (B \neq A)$ï¼Œ$j$ä¸å˜ï¼Œ$nxt[1]=0$
> >
> > æ­¤æ—¶$i=2, j=0, nxt = \{0, 0, 0, 0, 0, 0\}$
> >
> > å› ä¸º$s_2[i] \neq s_2[j]\ (C \neq A)$ï¼Œ$j$ä¸å˜ï¼Œ$nxt[2]=0$
> >
> > æ­¤æ—¶$i=3, j=0, nxt = \{0, 0, 0, 0, 0, 0\}$
> >
> > å› ä¸º$s_2[i] = s_2[j]\ (A = A)$ï¼Œ$j$+1ï¼Œ$nxt[3]=1$
> >
> > æ­¤æ—¶$i=4, j=1, nxt = \{0, 0, 0, 1, 0, 0\}$
> >
> > å› ä¸º$s_2[i] = s_2[j]\ (B = B)$ï¼Œ$j$+1ï¼Œ$nxt[4]=2$
> >
> > æ­¤æ—¶$i=5, j=2, nxt = \{0, 0, 0, 1, 2, 0\}$
> >
> > å› ä¸º$s_2[i] = s_2[j]\ (D \neq C)$ï¼Œ$j$+1ï¼Œ$nxt[5]=0$
> >
> > æœ€åå¾—åˆ°çš„$nxt = \{0, 0, 0, 1, 2, 0\}$



**KMPç®—æ³•çš„å®ç°**

```cpp
j = 0;
for(int i = 0; i < len1; i++){
  while(j > 0 && s1[i] != s2[j]) j = nxt[j - 1];
  if(s2[j] == s1[i]) j++;
  if(j == len2){
    std::cout << i - len2 + 1 << std::endl;//åŒ¹é…æˆåŠŸ,ä¸”åŒ¹é…åˆ°çš„é¦–ä½ä½i-len2+1
    j = nxt[j - 1];//å›æº¯é‡æ–°è¿›è¡ŒåŒ¹é…
  }
}
```

> ä¾‹å¦‚å¯¹äº$s_1$="ababababc",$s_2$="ababc"
>
> > å³æˆ‘éœ€è¦æ‰¾åˆ°ababcæ˜¯å¦åœ¨ababababcä¸­å‡ºç°ï¼Œè‹¥å‡ºç°åˆ™çœ‹ä¸‹åœ¨ç¬¬å‡ ä½å‡ºç°è¿‡
>
> nextæ•°ç»„ä¸º$nxt = \{0, 0, 1, 2, 0\}$
>
> æ­¤æ—¶$i = 0, j = 0$
>
> å› ä¸º$s_2[j] = s_1[i](a = a)$ï¼Œåˆ™$j$++
>
> æ­¤æ—¶$i=1,j=1$
>
> å› ä¸º$s_2[j] = s_1[i](b = b)$ï¼Œåˆ™$j$++
>
> æ­¤æ—¶$i=2,j=2$
>
> å› ä¸º$s_2[j] = s_1[i](a = a)$ï¼Œåˆ™$j$++
>
> æ­¤æ—¶$i=3,j=3$
>
> å› ä¸º$s_2[j] = s_1[i](b = b)$ï¼Œåˆ™$j$++
>
> æ­¤æ—¶$i=4,j=4$
>
> å› ä¸º$s_2[j] \neq s_1[i](c \neq a)$ï¼Œåˆ™è¿›å…¥whileå¾ªç¯
>
> > è¿›å…¥ç¬¬ä¸€æ¬¡whileå¾ªç¯ï¼Œ$j$=4ï¼Œ$j=nxt[3]=2$
> >
> > æ­¤æ—¶$s_2[j] = s_1[i](a = a)$ï¼Œåˆ™é€€å‡ºwhileå¾ªç¯
> >
> > æ­¤æ—¶å…¶å®ç›¸å½“äºä»
> >
> > ```
> > æ¨¡å¼ä¸²ï¼šababc
> > æ–‡æœ¬ä¸²ï¼šababababc
> > ```
> >
> > å˜æˆäº†
> >
> > ```
> > æ¨¡å¼ä¸²ï¼š  aba
> > æ–‡æœ¬ä¸²ï¼šababababc
> > ```
> >
> > é€€å‡ºå¾ªç¯åï¼Œå› ä¸º$s_2[j] = s_1[i](a = a)$ï¼Œæ‰€ä»¥$j$++
>
> æ­¤æ—¶$i=5,j=3$
>
> å› ä¸º$s_2[j] = s_1[i](b = b)$ï¼Œåˆ™$j$++
>
> æ­¤æ—¶$i=6,j=4$
>
> å› ä¸º$s_2[j] \neq s_1[i](c \neq a)$ï¼Œåˆ™è¿›å…¥whileå¾ªç¯
>
> > å…¥ç¬¬ä¸€æ¬¡whileå¾ªç¯ï¼Œ$j$=4ï¼Œ$j=nxt[3]=2$
> >
> > æ­¤æ—¶$s_2[j] = s_1[i](a = a)$ï¼Œåˆ™é€€å‡ºwhileå¾ªç¯
> >
> > æ­¤æ—¶å…¶å®ç›¸å½“äºä»
> >
> > ```
> > æ¨¡å¼ä¸²ï¼šababc
> > æ–‡æœ¬ä¸²ï¼šababababc
> > ```
> >
> > å˜æˆäº†
> >
> > ```
> > æ¨¡å¼ä¸²ï¼š    aba
> > æ–‡æœ¬ä¸²ï¼šababababc
> > ```
> >
> > é€€å‡ºå¾ªç¯åï¼Œå› ä¸º$s_2[j] = s_1[i](a = a)$ï¼Œæ‰€ä»¥$j$++
>
> æ­¤æ—¶$i=7,j=3$
>
> å› ä¸º$s_2[j] = s_1[i](b = b)$ï¼Œåˆ™$j$++
>
> æ­¤æ—¶$i=8,j=4$
>
> å› ä¸º$s_2[j] = s_1[i](c = c)$ï¼Œåˆ™$j$++
>
> æ­¤æ—¶çš„$j=len2=5$ï¼ŒåŒ¹é…æˆåŠŸ
>
> å¯ä»¥è¾“å‡º$i-len_2+1=4$ï¼Œä»£è¡¨åœ¨ä¸‹æ ‡ä¸º4ï¼Œå³ç¬¬5ä½ä¸­åŒ¹é…åˆ°äº†è¿™ä¸ªå­—ç¬¦ä¸²



<span id="KMP"></span>

**æ¨¡æ¿**

```cpp

```



### å›¾è®º

#### åŸºæœ¬æ¦‚å¿µ



##### äºŒåˆ†å›¾æ˜¯ä»€ä¹ˆ

è‹¥èƒ½å¤Ÿå°†å›¾åˆ†ä¸º**ä¸¤ä¸ªäº’ä¸ç›¸äº¤çš„é›†åˆï¼ˆUï¼ŒVï¼‰**ï¼Œä½¿å¾—å›¾ä¸­æ¯æ¡è¾¹éƒ½è¿æ¥ä¸€ä¸ªUä¸­çš„é¡¶ç‚¹å’Œä¸€ä¸ªVä¸­çš„é¡¶ç‚¹ï¼Œåˆ™ç§°è¯¥å›¾ä¸º**äºŒåˆ†å›¾**

ä¾‹å¦‚U={A, B},V = {C, D}ï¼Œè¾¹ä¸ºA->C, A->D, B->C



##### åŒ¹é…

åŒ¹é…ä¸ºä¸€ç»„è¾¹ï¼Œä¸”**ä»»æ„ä¸¤æ¡è¾¹æ²¡æœ‰å…¬å…±é¡¶ç‚¹**



##### æœ€å¤§åŒ¹é…

æœ€å¤§åŒ¹é…ä¸º**è¾¹æ•°æœ€å¤šçš„åŒ¹é…**

ä¾‹å¦‚ä¸Šè¿°ä¾‹å­ï¼Œæœ€å¤§åŒ¹é…ä¸ºA->C, B->Cï¼Œä¸€å…±æœ‰ä¸¤å¯¹



<span id="augmenting_path"></span>

##### å¢å¹¿è·¯

ä»ä¸€ä¸ª**ä¸ºåŒ¹é…é¡¶ç‚¹**å‡ºå‘ï¼Œäº¤æ›¿ç»è¿‡**éåŒ¹é…è¾¹**å’Œ**åŒ¹é…è¾¹**ï¼Œæœ€ç»ˆåˆ°è¾¾å¦ä¸€ä¸ª**æœªåŒ¹é…é¡¶ç‚¹**çš„è·¯å¾„

å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

* è·¯å¾„é•¿åº¦ä¸º**å¥‡æ•°**ï¼ˆè¾¹æ•°ä¸ºå¥‡æ•°ï¼‰
* è·¯å¾„çš„**èµ·ç‚¹å’Œç»ˆç‚¹éƒ½ä¸ºæœªåŒ¹é…é¡¶ç‚¹**
* è·¯å¾„ä¸Š**éåŒ¹é…è¾¹å’ŒåŒ¹é…è¾¹äº¤æ›¿å‡ºç°**

é€šè¿‡â€œåè½¬â€ï¼ˆå°†éåŒ¹é…è¾¹å˜ä¸ºåŒ¹é…è¾¹ï¼ŒåŒ¹é…è¾¹å˜ä¸ºéåŒ¹é…è¾¹ï¼‰å¢å¹¿è·¯ä¸Šè¾¹çš„çŠ¶æ€ï¼Œå¯ä»¥å°†åŒ¹é…æ•°**å¢åŠ 1**



<span id="network"></span>

##### ç½‘ç»œ

ä¸€ä¸ªç½‘ç»œæ˜¯ä¸€ä¸ª**æœ‰å‘å›¾$G=(V,E)$**ï¼Œä¸”æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

1. **å®¹é‡çº¦æŸ**
    æ¯æ¡è¾¹$(u,v) \in E$æœ‰ä¸€ä¸ªéè´Ÿçš„**å®¹é‡** $c(u,v)\geq0$ ï¼Œè¡¨ç¤ºè¾¹å…è®¸é€šè¿‡çš„**æœ€å¤§æµé‡**ã€‚è‹¥è¾¹ä¸å­˜åœ¨åˆ™å®¹é‡ä¸º0.

2. **æºç‚¹ä¸æ±‡ç‚¹**

  å›¾ä¸­åŒ…å«ä¸¤ä¸ªç‰¹æ®ŠèŠ‚ç‚¹

  * æºç‚¹(Source)ï¼šé€šå¸¸è®°ä¸º$s$ï¼Œè¡¨ç¤ºæµé‡çš„èµ·ç‚¹
  * æ±‡ç‚¹(Sink)ï¼šé€šå¸¸è®°ä¸º$t$ï¼Œè¡¨ç¤ºæµé‡çš„ç»ˆç‚¹

3. **æµé‡å®ˆæ’**
    å¯¹äºä¸­é—´èŠ‚ç‚¹$u \neq s, t$ï¼Œ**æµå…¥è¯¥èŠ‚ç‚¹çš„æµé‡æ€»å’Œ**ç­‰äº**æµå‡ºè¯¥èŠ‚ç‚¹çš„æµé‡ç»¼åˆ**ï¼Œå³ï¼š
$$
  \sum_{v_1 \in V}f(v_1, u) = \sum_{v_2 \in V}f(u, v_2)
$$
  å…¶ä¸­$f(u, v)$è¡¨ç¤ºè¾¹$(u, v)$ä¸Šçš„å®é™…æµé‡ã€‚

4. **å¯è¡Œæµ**
    æµé‡éœ€æ»¡è¶³ï¼š

  * **å®¹é‡é™åˆ¶**ï¼šå¯¹æ‰€æœ‰è¾¹$(u, v), 0 \leq f(u, v) \leq c(u, v)$
  * **æµé‡å®ˆæ’**ï¼šä¸­é—´èŠ‚ç‚¹çš„æµå…¥ç­‰äºæµå‡º

**æµå‡½æ•°**$f:V \times V \rightarrow \R$å®šä¹‰åœ¨èŠ‚ç‚¹å¯¹ä¸Šï¼Œåˆ™éœ€è¦æ»¡è¶³ï¼š

* åå¯¹ç§°æ€§ï¼š$f(u, v) = -f(v, u)$
* å®¹é‡çº¦æŸï¼š$f(u, v) \leq c(u, v)$

**æµçš„å€¼**å®šä¹‰ä¸º**ä»æºç‚¹æµå‡ºçš„å‡€æµé‡ï¼ˆæˆ–æ±‡ç‚¹æµå…¥çš„å‡€æµé‡ï¼‰**ï¼Œå³ï¼š
$$
\lvert f \rvert = \sum_{v \in V} f(s, v) - \sum_{v \in V}(v, s)
$$
ä¹Ÿå°±æ˜¯ä»æºç‚¹æµå‡ºå»çš„æ‰€æœ‰å€¼å‡å»æµå‘æºç‚¹çš„æ‰€æœ‰å€¼

> æœ‰ä¸€ä¸ªæ¯”è¾ƒç”Ÿæ´»çš„ä¾‹å­ï¼Œä¾‹å¦‚
>
> å¯¹äºä¸€å¼ æœ‰å‘å›¾ï¼ˆç½‘ç»œï¼‰ï¼Œæœ‰Nä¸ªç‚¹ï¼ŒMæ¡è¾¹ï¼Œæºç‚¹Så’Œæ±‡ç‚¹Tï¼Œå¯ä»¥ç†è§£æˆä¸º
>
> å¯¹äºä¸€ä¸ªåŸå¸‚çš„æ°´ç½‘ï¼Œæœ‰Næˆ·å®¶åº­ï¼ŒMæ¡ç®¡é“ä»¥åŠä¾›æ°´ç‚¹Så’Œæ±‡åˆç‚¹T



##### æ®‹é‡ç½‘ç»œ

åœ¨ä»»æ„æ—¶åˆ»ï¼Œç½‘ç»œä¸­æ‰€æœ‰èŠ‚ç‚¹ä»¥åŠå‰©ä½™å®¹é‡å¤§äº0çš„è¾¹æ„æˆçš„å­å›¾è¢«ç§°ä¸º**æ®‹é‡ç½‘ç»œ**



#### åŒ¹é…é—®é¢˜

##### åŒˆç‰™åˆ©ç®—æ³•(äºŒåˆ†å›¾æœ€å¤§åŒ¹é…)

> ä¾‹é¢˜ï¼š[P3386 ã€æ¨¡æ¿ã€‘äºŒåˆ†å›¾æœ€å¤§åŒ¹é…](https://www.luogu.com.cn/problem/P3386)
>
> [B3605 [å›¾è®ºä¸ä»£æ•°ç»“æ„ 401] äºŒåˆ†å›¾åŒ¹é…](https://www.luogu.com.cn/problem/B3605)

åŸç†æ˜¯é€šè¿‡å¯»æ‰¾[å¢å¹¿è·¯](#augmenting_path)æ¥å¢åŠ åŒ¹é…æ•°é‡ï¼Œæ­¥éª¤ä¸º

1. åˆå§‹åŒ–æ‰€æœ‰é¡¶ç‚¹ä¸ºæœªåŒ¹é…çŠ¶æ€
2. å¯¹å·¦è¾¹æ¯ä¸ªé¡¶ç‚¹å°è¯•å¯»æ‰¾å¢å¹¿è·¯å¾„
3. ä½¿ç”¨DFSæœç´¢è·¯å¾„ï¼Œæ‰¾åˆ°åˆ™åè½¬è¾¹çŠ¶æ€

```cpp
int n, m, e;//å·¦éƒ¨ç‚¹ä¸ªæ•°ä¸ºnï¼Œå³éƒ¨ç‚¹ä¸ªæ•°ä¸ºmï¼Œæœ‰eæ¡è¾¹
std::cin >> n >> m >> e;
//aå­˜çš„æ˜¯å·¦ä¾§çš„ç‚¹ä¸å³ä¾§çš„ç‚¹çš„è¿çº¿ï¼Œæ‰€ä»¥å¤§å°ä¸ºn+5
//matchè¡¨ç¤ºä¸å³è¾¹é¡¶ç‚¹åŒ¹é…çš„å·¦è¾¹é¡¶ç‚¹ï¼Œæ‰€ä»¥å¤§å°ä¸ºm+5
std::vector<int> a[n + 5], match(m + 5);
for(int i = 1;i <= e;i++){
	int u, v;
	std::cin >> u >> v;
	//å­˜å…¥u->vçš„å•å‘è¾¹
	a[u].push_back(v);
}
auto hungarian = [&]() -> int{
	int cnt = 0;
	for(int u = 1; u <= n; u++){
		//visæ ‡è®°çš„æ˜¯å³éƒ¨ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ï¼Œæ‰€ä»¥å¤§å°ä¸ºm+5
		std::vector<int> vis(m + 5);
		std::function<bool(int)>dfs = [&](int u) -> bool{
			for(int v : a[u])
				if(!vis[v]){
					vis[v] = 1;
					//å¦‚æœvæœªåŒ¹é…ï¼Œæˆ–è€…å·²ç»åŒ¹é…ä½†èƒ½ä¸ºmatch[v]æ‰¾åˆ°æ–°çš„å¢å¹¿è·¯
					if(!match[v] || dfs(match[v])){
						match[v] = u;//å°†våŒ¹é…ç»™u
						return true;//æ‰¾åˆ°äº†å¢å¹¿è·¯å¾„
					}
				}
			return false;
		};
		if(dfs(u))cnt++;
	}
	return cnt;
};
std::cout << hungarian() << endl;
```



#### å»ºè¾¹

##### é‚»æ¥è¡¨

```cpp
std::vector<int> e[n + 5];
//è‹¥x yè¡¨ç¤ºxæŒ‡å‘yçš„å•å‘è¾¹
for(int i = 1;i <= m;i++){
  int x, y;
  std::cin >> x >> y;
  e[x].push_back(y);
}
//è‹¥x yè¡¨ç¤ºxä¸yçš„åŒå‘è¾¹
for(int i = 1;i <= m;i++){
  int x, y;
  std::cin >> x >> y;
  e[x].push_back(y);
  e[y].push_back(x);
}
//è‹¥uè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ vè¡¨ç¤ºè¦è®¿é—®çš„èŠ‚ç‚¹ åˆ™é‚»æ¥è¡¨çš„è®¿é—®æ–¹å¼ä¸º
//for eachå†™æ³•
for(auto v : e[u]){
  //åœ¨æ­¤å¯¹vè¿›è¡Œæ“ä½œ
}
//æ™®é€šforå†™æ³•
for(int i = 0;i < e[u].size();i++){
  v = e[u][i];
  //åœ¨æ­¤å¯¹vè¿›è¡Œæ“ä½œ
}
```

##### é“¾å¼å‰å‘æ˜Ÿ

```cpp
struct edge{
  int next, to;
};
std::vector<edge> e(m * 2 + 5);//åŒå€è¾¹
std::vector<int> head(n + 5, -1);
int cnt = 0;
auto add = [&](int x, int y) -> void{
  //æ­¤ä¸ºx->y
  e[cnt].next = head[x];
  e[cnt].to = y;
  head[x] = cnt++;
  //æ­¤ä¸ºy->x
  e[cnt].next = head[y];
  e[cnt].to = x;
  head[y] = cnt++;
};
//æ­¤å¤„ä¸ºéå†æ–¹å¼
for(int i = head[u];~i;i = e[i].next){
  int v = e[i].to;
  //æ­¤å¤„å¯¹vè¿›è¡Œæ“ä½œ
}
```

#### æ‹“æ‰‘æ’åº

```cpp
std::vector<int> ind(n + 5), e[n + 5];
for(int i = 1;i <= n;i++){
  int x, y;//è¿™é‡Œçš„x yè¡¨ç¤ºæœ‰ä¸€æ¡xæŒ‡å‘yçš„å•å‘è¾¹
  std::cin >> x >> y;
  e[x].push_back(y);
  ind[y]++;
}
std::queue<int> q;
for(int i = 1;i <= n;i++)
  if(!ind[i])
    q.push(i);
while(!q.empty()){
  int u = q.front();
  q.pop();
  for(auto v : e[u]){
    ind[v]--;
    //è¿™é‡Œè¿›è¡Œæ“ä½œ
    if(!ind[v])q.push(v);
  }
}
```

> ä¾‹é¢˜ï¼š[P4017 æœ€å¤§é£Ÿç‰©é“¾è®¡æ•°](https://www.luogu.com.cn/problem/P4017)

#### tarjanå®ç°ç¼©ç‚¹

```cpp
//æ­¤å¤„ä½¿ç”¨é‚»æ¥è¡¨å­˜å‚¨å›¾
std::vector<int> belong(n + 5), e[n + 5], dfn(n + 5), vis(n + 5), low(n + 5), s(n + 5);
int tot = 0, index = 0, t = 0;
std::function<void(int)>tarjan = [&](int x) -> void{
  dfn[x] = low[x] = ++t;
  s[++index] = x;
  vis[x] = 1;
  for(auto v : e[x]){
    if(!dfn[v]){
      tarjan(v);
      low[x] = std::min(low[x], low[v]);
    }else if(vis[v])
      low[x] = std::min(low[x], dfn[v]);
  }
  if(low[x] == dfn[x]){
    tot++;
    while(1){
      belong[s[index]] = tot;
      vis[s[index]] = 0;
      index--;
      if(x == s[index + 1])break;
      //æ­¤å¤„è¿›è¡Œåˆå¹¶æ“ä½œ
    }
  }
};
for(int i = 1;i <= n;i++)
  if(!dfn[i])tarjan(i);
```

> ç¼©ç‚¹ï¼Œå³å°†ä¸€ä¸ªç¯è¿›è¡Œæ“ä½œï¼Œå¹¶å°†ä¸€æ•´ä¸ªç¯æŠ½è±¡æˆä¸€ä¸ªç‚¹
>
> ä¾‹é¢˜ï¼š[P3387 ã€æ¨¡æ¿ã€‘ç¼©ç‚¹](https://www.luogu.com.cn/problem/P3387)



#### æœ€å°ç”Ÿæˆæ ‘

>ä¾‹é¢˜ï¼š[P3366 ã€æ¨¡æ¿ã€‘æœ€å°ç”Ÿæˆæ ‘](https://www.luogu.com.cn/problem/P3366)

##### Prim

```cpp
//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå»ºå›¾
int cnt = 0, cur = 1, tot = 0, ans = 0;
struct edge{
  int next, to, val;
};
std::vector<int> dis(n + 5, 1e9), head(n + 5, -1), vis(n + 5);
std::vector<edge> a(m + 5);
auto add = [&](int u, int v, int val) -> void{
  a[cnt].next = head[u];
  a[cnt].to = v;
  a[cnt].val = val;
  head[u] = cnt++;
};
for(int i = 1;i <= m;i++){
  int u, v, val;
  //æ­¤å¤„ä»¥åŒå‘è¾¹ä¸ºä¾‹å­
  add(u, v, val);
  add(v, u, val);
}
//æ­¤å¤„ä¸ºprimç®—æ³•
for(int i = head[1];~i;i = e[i].next)
  dis[e[i].to] = std::min(dis[e[i].to], e[i].val);
while(++tot < n){
  int mn = 1e9;
  vis[cur] = 1;
  for(int i = 1;i <= n;i++)
    if(!vis[i] && minn > dis[i]){
      minn = dis[i];
      cur = i;
    }
  ans += minn;
  for(int i = head[cur];~i;i = e[i].next){
    int v = e[i].to, val = e[i].val;
    if(!vis[v] && dis[v] > val)
      dis[v] = val;
  }
}
std::cout << ans << endl;
```

> ç®—æ³•å®ç°åŸç†ï¼š
>
> <img src="./img/prim-1.png" width="300px"/>
>
> <img src="./img/prim-2.png" width="300px"/>
>
> é€šè¿‡ç‚¹1ï¼Œå¯¹ç›¸é‚»ç‚¹çš„distè¿›è¡Œæ›´æ–°ï¼Œç»“æœå¦‚ä¸‹ï¼š
>
> <img src="./img/prim-3.gif" width="300px"/>
>
> å°†ä¸1æœ€è¿‘çš„ç‚¹2åŠ å…¥ç”Ÿæˆæ ‘ä¸­
>
> <img src="./img/prim-4.png" width="300px"/>
>
> æ­¤æ—¶ç”¨2æ¥æ›´æ–°distæ•°ç»„
>
> <img src="./img/prim-5.gif" width="300px"/>
>
> é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°æ‰€æœ‰çš„ç‚¹éƒ½åŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘ä¸­
>
> <img src="./img/prim-6.png" width="300px"/>
>
> <img src="./img/prim-7.png" width="300px"/>
>
> <img src="./img/prim-8.png" width="300px"/>
>
> <img src="./img/prim-9.png" width="300px"/>
>
> <img src="./img/prim-10.png" width="300px"/>
>
> <img src="./img/prim-11.png" width="300px"/>
>
> <img src="./img/prim-12.png" width="300px"/>
>
> <img src="./img/prim-13.png" width="300px"/>
>
> <img src="./img/prim-14.png" width="300px"/>

##### Kruskal

```cpp
int n, m;
std::cin >> n >> m;
std::vector<int> f(n + 5);
std::vector<std::array<int, 3>> e;
for(int i = 1;i <= n;i++)f[i] = i;
for(int i = 1;i <= m;i++){
  int x, y, val;
  std::cin >> x >> y >> val;
  //è‹¥å­˜åœ¨x->yçš„å•å‘è¾¹
  e.push_back({x, y, val});
  //è‹¥å­˜åœ¨y->xçš„å•å‘è¾¹
  e.push_back({y, x, val});
}
auto Kruskal = [&]() -> int{
  DSU dsu(n);
  int ans = 0, cc = 0;
  std::sort(e.begin(), e.end(), [&](const std::array<int, 3> &x, const std::array<int, 3> &y) -> bool{
    return x[2] < y[2];
  });//æŒ‰ç…§è¾¹æƒä»å°åˆ°å¤§æ’åº
  for(auto [u, v, val] : e){
    if(!dsu.same(u, v)){
      dsu.merge(u, v);
      ans += val;
      cc++;
      if(cc == n - 1)break;//å¦‚æœåŠ å…¥äº†n-1ä¸ªç‚¹ï¼Œåˆ™è¡¨ç¤ºè”é€šäº†nä¸ªç‚¹ï¼Œæ­¤æ—¶å·²ç»å®Œæˆæœ€å°ç”Ÿæˆæ ‘çš„æ„å»º
    }
  }
  return ans;
};
std::cout << Kruskal() << endl;
return awa;
```

> [dsuè¯¦è§£ç‚¹æ­¤å¤„](#dsu)ï¼Œæ­¤å¤„å±•ç¤ºdsuå°è£…çš„æ¨¡æ¿
>
> ```cpp
> class DSU{
> private:
> 	int n;
> 	std::vector<int> f, sz;
> public:
> 	DSU(int x){
> 		n = x;
> 		f.resize(n + 5);
> 		sz.resize(n + 5, 1);
> 		for(int i = 1;i <= n;i++)f[i] = i;
> 	}
> 	
> 	int find(int x){
> 		if(f[x] != x)f[x] = find(f[x]);
> 		return f[x];
> 	}
> 	//åˆå¹¶x y
> 	void merge(int x, int y){
> 		int cx = find(x), cy = find(y);
> 		f[cy] = cx;
> 		sz[cy] += sz[cx];
> 	}
> 	//åˆ¤æ–­x yæ˜¯å¦å±äºä¸€ä¸ªè”é€šå—
> 	bool same(int x, int y){
> 		return find(x) == find(y);
> 	}
> 	//åˆ¤æ–­æŸä¸ªè”é€šå—æœ‰å‡ ä¸ªèŠ‚ç‚¹
> 	int get_size(int x){
> 		return sz[x];
> 	}
> };
> ```



#### å•æºæœ€çŸ­è·¯

> è‹¥ä¸å«è´Ÿæƒè¾¹ï¼Œåˆ™ä¼˜å…ˆä½¿ç”¨Dijkstraï¼ˆæ—¶é—´å¤æ‚åº¦O((n+m)logm)ï¼Œå› ä¸ºæœ‰äº›é¢˜ç›®ä¼šæ„é€ ä½¿spfaè¶…æ—¶çš„ç®—æ³•
>
> è‹¥éœ€è¦æ£€æµ‹è´Ÿæƒç¯ï¼Œåˆ™ä½¿ç”¨Bellman-Fordï¼ˆæ—¶é—´å¤æ‚åº¦O(VE))ï¼Œå…¶ä¸­Vä¸ºç‚¹æ•°ï¼ŒEä¸ºè¾¹æ•°
>
> è‹¥å«è´Ÿæƒè¾¹ä¸”ä¸éœ€è¦æ£€æµ‹è´Ÿæƒç¯ï¼Œåˆ™ä½¿ç”¨SPFAï¼ˆæœ€å¥½æ—¶é—´å¤æ‚åº¦O(V+E)ï¼Œæœ€åO(VE)ï¼‰

<span id="Dijkstra"></span>

##### Dijkstra

> åªé€‚ç”¨äºä¸å«**è´Ÿæƒè¾¹**çš„å›¾
>
> ä¾‹é¢˜ï¼š[P4779 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆæ ‡å‡†ç‰ˆï¼‰](https://www.luogu.com.cn/problem/P4779)

```cpp
//æ³¨æ„æ­¤å¤„ä½¿ç”¨äº†ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæƒ³è¦å…ƒç´ ä»å°åˆ°å¤§æ’ï¼Œé‡è½½è¿ç®—ç¬¦è¦**ä»å¤§åˆ°å°**ï¼Œå› ä¸ºå †çš„æ€§è´¨ï¼ˆå¯ä»¥è‡ªè¡Œäº†è§£ï¼‰ï¼ï¼
class cmp{
public:
	bool operator()(const PII &x, const PII &y) const {
		return x.second > y.second;
	}
};

//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå»ºå›¾
struct edge{
	int to, val, next;
};

int cnt = 0;
std::vector<edge> e(m + 5);
std::vector<int> head(n + 5, -1), dis(n + 5, 1e9), vis(n + 5);

auto add = [&](int u, int v, int val) -> void{
	e[cnt].next = head[u];
	e[cnt].to = v;
	e[cnt].val = val;
	head[u] = cnt++;
};
//æ­¤å¤„æœ‰mæ¡u->vï¼Œè¾¹æƒä¸ºdisçš„å•å‘è¾¹
for(int i = 1;i <= m;i++){
  int u, v, dis;
  std::cin >> u >> v >> dis;
  add(u, v, dis);
}
//ä»¥ä¸‹ä¸ºDijkstraï¼Œsä¸ºæºç‚¹
auto Dijkstra = [&]() -> void{
  std::priority_queue<PII, std::vector<PII>, cmp> q;
  q.push({s, 0});//PIIä¸­å­˜çš„ä¸º{u, dis}ï¼Œuä»£è¡¨å½“å‰ç‚¹ï¼Œdisä»£è¡¨æºç‚¹åˆ°æ­¤ç‚¹çš„è·ç¦»
  dis[s] = 0;
  while(!q.empty()){
    PII x = q.top();
    auto [u, val] = x;
    q.pop();
    if(vis[u])continue;
    vis[u] = 1;
    for(int i = head[u]; ~i; i = e[i].next){
      int v = e[i].to;
      if(dis[v] > dis[u] + e[i].val){
        dis[v] = dis[u] + e[i].val;
        if(!vis[v])q.push({v, dis[v]});
      }
    }
  }
  //æœ€ç»ˆæ¯ä¸ªç‚¹iè·ç¦»æºç‚¹sçš„è·ç¦»éƒ½ä¸ºdis[i]ï¼Œè‹¥æ— æ³•åˆ°è¾¾åˆ™è·ç¦»ä¸º1e9
};
```



<span id="SPFA"></span>

##### SPFA

> é€‚ç”¨äº**ç¨€ç–å›¾ï¼Œæ— è´Ÿæƒç¯çš„å›¾æˆ–è€…åŠ¨æ€å›¾**ï¼Œä¾‹å¦‚**éœ€è¦é¢‘ç¹æ›´æ–°æœ€çŸ­è·¯å¾„çš„åœºæ™¯ï¼ˆç½‘ç»œè·¯ç”±ï¼‰**
>
> æœ€åæ—¶é—´å¤æ‚åº¦ä¸ºO(V*E)
>
> ä¾‹é¢˜ï¼š[P3371 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆå¼±åŒ–ç‰ˆï¼‰](https://www.luogu.com.cn/problem/P3371)
>
> [P3385 ã€æ¨¡æ¿ã€‘è´Ÿç¯](https://www.luogu.com.cn/problem/P3385)

```cpp
int n, m, s, cnt = 0;
std::cin >> n >> m >> s;
std::vector<edge> e(m + 5);
std::vector<int> vis(n + 5), head(n + 5, -1), dis(n + 5, 1e9), count(n + 5);
//æ­¤å¤„ä»¥é“¾å¼å‰å‘æ˜Ÿå­˜å›¾
auto add = [&](int u, int v, int val) -> void{
	e[cnt].next = head[u];
	e[cnt].to = v;
	e[cnt].val = val;
	head[u] = cnt++;
};
for(int i = 1;i <= m;i++){
	int u, v, w;
	std::cin >> u >> v >> w;
  //æ­¤å¤„ä¸ºu->vçš„å•å‘è¾¹ï¼Œä¸”æƒå€¼ä¸ºw
	add(u, v, w);
}
auto SPFA = [&]() -> bool{
	dis[s] = 0;//sä¸ºæºç‚¹
	std::queue<int> q;
	q.push(s);
	vis[s] = 1;//æ ‡è®°så·²ç»å…¥é˜Ÿ
	while(!q.empty()){
		int u = q.front();
		q.pop();
		vis[u] = false;//æ ‡è®°å…¶å‡ºé˜Ÿ
		for(int i = head[u]; ~i; i = e[i].next){
			int v = e[i].to, val = e[i].val;
			if(dis[v] > dis[u] + val){
				dis[v] = dis[u] + val;
				if(!vis[v]){//è‹¥æ²¡å…¥é˜Ÿ
					vis[v] = 1;//è®©å…¶å…¥é˜Ÿ
					count[v]++;//è®°å½•å…¶å…¥é˜Ÿçš„æ¬¡æ•°
					if(count[v] > n)return false;//è‹¥å…¥é˜Ÿæ¬¡æ•°>nï¼Œåˆ™å­˜åœ¨è´Ÿæƒç¯ï¼Œè¿”å›false
					q.push(v);
				}
			}
		}
	}
	return true;//è‹¥è¿”å›trueï¼Œåˆ™è¡¨ç¤ºå›¾ä¸­ä¸å­˜åœ¨è´Ÿæƒç¯
};
SPFA();
//æœ€ç»ˆæºç‚¹åˆ°æ¯ä¸ªç‚¹çš„è·ç¦»å­˜åœ¨disæ•°ç»„ä¸­ï¼Œè‹¥æ— æ³•åˆ°è¾¾ï¼Œåˆ™ä¸º1e9
```



##### Bellman-Ford

> é€‚ç”¨äº**ç¨ å¯†å›¾ä¸”V(é¡¶ç‚¹æ•°)è¾ƒå°çš„æƒ…å†µ**ï¼Œéœ€è¦**æ£€æµ‹è´Ÿæƒç¯**çš„åœºæ™¯
>
> æœ€åæ—¶é—´å¤æ‚åº¦ä¸ºO(V*E)



#### å…¨æºæœ€çŸ­è·¯

##### Floyd

> æ—¶é—´å¤æ‚åº¦**O(n^3)**ï¼Œé€‚ç”¨äºn<=500çš„æƒ…å†µï¼Œèƒ½å¤Ÿæ±‚æ‰€æœ‰ç‚¹å¯¹(i, j)çš„æœ€çŸ­è·¯å¾„

```cpp
int n, m;
std::cin >> n >> m;
std::vector<std::vector<int>> f(n + 5, std::vector<int>(n + 5, 1e9));//å°†è·ç¦»å€¼è®¾ä¸ºæœ€å¤§å€¼
for(int i = 1;i <= m;i++){
	int u, v, w;
	std::cin >> u >> v >> w;
	f[u][v] = f[v][u] = std::min(f[u][v], w);//ç¡®ä¿ç›®å‰å­˜ä¸‹æ¥çš„æ˜¯u<->vçš„æœ€çŸ­è·¯
}
for(int i = 1;i <= n;i++)f[i][i] = 0;
//Floyd
for(int k = 1;k <= n;k++)
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++)
			f[i][j] = std::min(f[i][j], f[i][k] + f[k][j]);
//è¾“å‡ºç»“æœ
for(int i = 1;i <= n;i++){
	for(int j = 1;j <= n;j++)std::cout << f[i][j] << " ";
	std::cout << endl;
}
```





<span id="Johnson"></span>

##### Johnsonç®—æ³•

> æ—¶é—´å¤æ‚åº¦$O(n^2m)$ï¼Œé€šè¿‡Dijkstraä¼˜åŒ–åå¯ä»¥è¾¾åˆ°$O(nm\ log\ m)$
>
> ä¾‹é¢˜ï¼š[P5905 ã€æ¨¡æ¿ã€‘å…¨æºæœ€çŸ­è·¯ï¼ˆJohnsonï¼‰](https://www.luogu.com.cn/problem/P5905)

Johnsonç®—æ³•é€šè¿‡æ–°å»ºä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼ˆæ­¤å¤„è®¾å®ƒçš„ç¼–å·ä¸º0ï¼‰ï¼Œä»è¿™ä¸ªç‚¹å‘å…¶ä»–æ‰€æœ‰ç‚¹è¿ä¸€æ¡è¾¹æƒä¸º 0 çš„è¾¹ã€‚

æ¥ä¸‹æ¥ç”¨ Bellman-Ford ç®—æ³•æ±‚å‡º 0 å·ç‚¹åˆ°å…¶ä»–æ‰€æœ‰è·¯çš„æœ€çŸ­è·¯ï¼Œè®°ä¸º $h_i$ ã€‚

å‡å¦‚å­˜åœ¨ä¸€æ¡ä» $u$ ç‚¹åˆ° $v$ ç‚¹ï¼Œè¾¹æƒä¸º $w$ çš„è¾¹ï¼Œåˆ™æˆ‘ä»¬å°†è¯¥è¾¹çš„è¾¹æƒé‡æ–°è®¾ç½®ä¸º $w+h_u-h_v$

æ¥ä¸‹æ¥ä»¥æ¯ä¸ªç‚¹ä¸ºèµ·ç‚¹ï¼Œè·‘ $n$ è½® Dijkstra ç®—æ³•å³å¯æ±‚å‡ºä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯äº†ã€‚

æ³¨æ„æœ€åçš„ç­”æ¡ˆä¸º $dis[u][v] - h[u] + h[v]$ å³ç”±åŠ æƒå€¼å¾—åˆ°åŸæ¥çš„å€¼



**æ­£ç¡®æ€§è¯æ˜**

Johnsonç®—æ³•ç”¨åˆ°çš„ $h$ æ•°ç»„ï¼Œå®é™…ä¸Šç±»ä¼¼äºç‰©ç†æ¦‚å¿µä¸Šçš„**åŠ¿èƒ½**

è¯¸å¦‚é‡åŠ›åŠ¿èƒ½ï¼Œç”µåŠ¿èƒ½è¿™æ ·çš„åŠ¿èƒ½éƒ½æœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼šåŠ¿èƒ½çš„å˜åŒ–é‡åªå’Œèµ·ç‚¹å’Œç»ˆç‚¹çš„**ç›¸å¯¹ä½ç½®**æœ‰å…³ï¼Œè€Œä¸èµ·ç‚¹åˆ°ç»ˆç‚¹æ‰€èµ°çš„è·¯å¾„æ— å…³ã€‚ä¸”åŠ¿èƒ½çš„ç»å¯¹å€¼å¾€å¾€å–å†³äºè®¾ç½®çš„é›¶åŠ¿èƒ½ç‚¹ï¼Œä½†æ— è®º**é›¶åŠ¿èƒ½ç‚¹è®¾ç½®åœ¨å“ªé‡Œï¼Œä¸¤ç‚¹é—´åŠ¿èƒ½çš„å·®å€¼æ˜¯ä¸€å®šçš„ã€‚**

å¯¹äºå¤„ç†çš„å›¾ä¸­ï¼Œå‡è®¾æœ‰ä¸€æ¡ä» $s$ åˆ° $t$ çš„è·¯å¾„ $s \rightarrow p_1 \rightarrow p_2 \rightarrow \cdots \rightarrow p_k \rightarrow t$ ï¼Œå…¶é•¿åº¦è¡¨è¾¾å¼å¦‚ä¸‹ï¼š
$$
(w(s, p_1) + h_s - h_{p_1}) + (w(p_1, p_2) + h_{p_1} - h_{p_2}) + \cdots + (w(p_k, t) + h_{p_k} - h_t)
$$
åŒ–ç®€åå¾—åˆ°ï¼š
$$
w(s, p_1) + w(p_1, p_2) + \cdots + w(p_k, t) + h_s - h_t
$$
æ— è®ºä» $s$ åˆ° $t$ èµ°çš„æ˜¯é‚£ç§è·¯å¾„ï¼Œ$h_s - h_t$ çš„å€¼æ˜¯ä¸å˜çš„ï¼Œä¸åŠ¿èƒ½çš„æ€§è´¨ç›¸å»åˆ

ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬å°† $h_i$ ç§°ä¸º $i$ ç‚¹çš„åŠ¿èƒ½

ä¸Šé¢çš„è¡¨è¾¾å¼
$$
w(u, v) + h_u - h_v \ (u, v \in V)
$$
å‰åŠéƒ¨åˆ†ä¸ºåŸå›¾ä¸­ $u \rightarrow v$ çš„æœ€çŸ­è·¯ï¼ŒååŠåˆ†ä¸ºä¸¤ç‚¹é—´çš„åŠ¿èƒ½å·®ã€‚åˆä¸¤ç‚¹é—´åŠ¿èƒ½å·®ä¸ºå®šå€¼ï¼Œå› æ­¤åŸå›¾ä¸Š $u \rightarrow v$ çš„æœ€çŸ­è·¯å’Œæ–°å›¾ä¸Š $u \rightarrow v$ çš„æœ€çŸ­è·¯ç›¸å¯¹åº”ã€‚

æ–°å›¾ä¸Šä»»æ„ä¸€è¾¹ $(u, v)$ ä¸Šä¸¤ç‚¹æ»¡è¶³ $h_v \leq h_u + w(u, v)$ï¼Œè¿™æ¡è¾¹é‡æ–°æ ‡è®°åçš„è¾¹æƒä¸º
$$
 w^{'}(u, v) = w(u, v) + h_u - h_v \geq 0 
$$
è¿™æ ·æ„å»ºçš„æ–°å›¾ä¸Šè¾¹æƒéƒ½ä¸ä¸ºè´Ÿ



**æ¨¡æ¿**

```cpp
//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå­˜å›¾
struct edge{
    int from, to, next, val;
};
//æ­¤å¤„æ˜¯é‡è½½è¿ç®—ç¬¦
class cmp{
public:    
  bool operator()(const PII &x, const PII &y){  
    return x.second > y.second;    
    //å› ä¸ºé‡è½½çš„æ˜¯å †ï¼Œæ‰€ä»¥æ¯”è¾ƒå‡½æ•°è¦ä»å¤§åˆ°å°ï¼Œè¿™æ ·è¾“å‡ºçš„ç»“æœä¸ºä»å°åˆ°å¤§    
  }
};
int n, m;    
std::cin >> n >> m;
std::vector<edge> e(n + m + 5); //é¢„ç•™ç©ºé—´ï¼ˆåŸè¾¹+è™šæ‹ŸèŠ‚ç‚¹è¾¹ï¼‰ 
//countä¸ºspfaå…¥é˜Ÿæ¬¡æ•°ï¼Œhä¸ºåŠ¿èƒ½ï¼Œvisä¸ºspfaæ˜¯å¦å·²å…¥é˜Ÿ
std::vector<int> head(n + 5, -1), h(n + 5, 1e9), count(n + 5), vis(n + 5);
//u->vçš„æœ€çŸ­è·¯
std::vector<std::vector<int>> dis(n + 5, std::vector<int>(n + 5, 1e9));
int cnt = 0;
//é“¾å¼å‰å‘æ˜Ÿæ·»åŠ è¾¹
auto add = [&](int u, int v, int val) -> void{
  e[cnt].from = u;  
  e[cnt].to = v;  
  e[cnt].next = head[u];  
  e[cnt].val = val;  
  head[u] = cnt++;  
};
for(int i = 1;i <= m;i++){
  int u, v, w;  
  std::cin >> u >> v >> w;  
  //å­˜åœ¨u->vçš„å•å‘è¾¹ï¼Œè¾¹æƒä¸ºw
  add(u, v, w);  
}
//æ·»åŠ è™šæ‹ŸèŠ‚ç‚¹0ï¼Œå¹¶ä¸”å»ºè¾¹0->iï¼Œè¾¹æƒä¸º0
for(int i = 1;i <= n;i++)
  add(0, i, 0);
//spfaå¤„ç†åŠ¿èƒ½
auto spfa = [&]() -> bool{        
  std::queue<int> q;        
  q.push(0);        
  h[0] = 0;//åˆå§‹åŒ–åŠ¿èƒ½       
  while(!q.empty()){  
    int u = q.front();    
    q.pop();    
    vis[u] = 0;    
    for(int i = head[u]; ~i; i = e[i].next){    
      int v = e[i].to, val = e[i].val;      
      if(h[v] > h[u] + val){      
        h[v] = h[u] + val;        
        if(!vis[v]){        
          q.push(v);          
          vis[v] = 1;          
          count[v]++;          
          //ç‚¹æœ‰n+1ä¸ªï¼Œè‹¥å…¥é˜Ÿè¶…è¿‡n+1æ¬¡ï¼Œåˆ™å­˜åœ¨è´Ÿç¯ï¼Œè¿”å›false       
          if(count[v] > n + 1)return false;          
        }        
      }      
    }    
  }
  return true;  
};
if(!spfa()){//è‹¥å­˜åœ¨è´Ÿç¯ï¼Œç›´æ¥è¾“å‡º-1
  std::cout << -1 << endl;       
  return awa;  
}
for(int i = 0;i < cnt;i++){        
  auto &[u, v, next, val] = e[i];  
  if(u)//è™šæ‹ŸèŠ‚ç‚¹çš„è¾¹ä¸éœ€è¦è°ƒæ•´ï¼Œè™½ç„¶è°ƒæ•´äº†ä¹Ÿæ²¡å…³ç³»  
    val += h[u] - h[v];//è°ƒæ•´è¾¹æƒ   
}
//è·‘nédijkstraï¼Œå½“å‰ä»¥uä¸ºæºç‚¹
auto dijkstra = [&](int u) -> void{
  //æ­¤å¤„pairå­˜çš„æ˜¯ u disï¼Œå³ ç‚¹ è·ç¦»  
  std::priority_queue<PII, std::vector<PII>, cmp> q;  
  dis[u][u] = 0;  
  q.push({u, 0});  
  while(!q.empty()){  
    auto [p, cur] = q.top();    
    q.pop();    
    //è‹¥å½“å‰è·ç¦»æ¯”ä¹‹å‰çš„æœ€çŸ­è·¯æ›´é•¿ï¼Œæˆ–è€…å½“å‰å¤„ç†çš„æ˜¯è™šæ‹ŸèŠ‚ç‚¹ï¼Œåˆ™è·³è¿‡    
    if(cur > dis[u][p] || !p) continue;    
    for(int i = head[p]; ~i; i = e[i].next){    
      int v = e[i].to, val = e[i].val;      
      if(dis[u][v] > dis[u][p] + val){      
        dis[u][v] = dis[u][p] + val;        
        q.push({v, dis[u][v]});        
      }      
    }    
  }  
};
//è·‘nédijkstra
for(int i = 1;i <= n;i++)
  dijkstra(i);
//æœ€ç»ˆu, vçš„ç­”æ¡ˆä¸º dis[i][j] - h[i] + h[j]
```



#### æœ€è¿‘å…¬å…±ç¥–å…ˆ(LCA)

> ä¾‹é¢˜ï¼š[P3379 ã€æ¨¡æ¿ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰](https://www.luogu.com.cn/problem/P3379)

##### å€å¢æ³•æ±‚LCA

> é€‚ç”¨äº**å®æ—¶æŸ¥è¯¢ï¼Œå¤šæ¬¡åŠ¨æ€æŸ¥è¯¢**ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºé¢„å¤„ç†O(n log n)ï¼ŒæŸ¥è¯¢O(logn)

```cpp
//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå»ºè¾¹
struct edge{
	int next, to;
};
int n, m, s, cnt = 0;
std::cin >> n >> m >> s;//sä¸ºæ ‘æ ¹ç¼–å·
std::vector<edge> e(n * 2 + 5);//åŒå‘è¾¹æ‰€ä»¥è¦ä¸¤å€ç©ºé—´
std::vector<int> head(n + 5, -1), dep(n + 5);
std::vector<std::vector<int>> f(n + 5, std::vector<int>(20));
//æ­¤å¤„å› ä¸ºn<=500000,2^19=524288>500000,æ‰€ä»¥æ­¤å¤„fçš„ç¬¬äºŒç»´å¤§å°ä¸º20(0~19)
//è¯·æ ¹æ®é¢˜ç›®èŒƒå›´è°ƒæ•´fçš„å¤§å°
auto add = [&](int x, int y) -> void{
	e[cnt].next = head[x];
	e[cnt].to = y;
	head[x] = cnt++;
};
for(int i = 1;i < n;i++){
	int x, y;
	std::cin >> x >> y;
  //æ·»åŠ x<->yçš„åŒå‘è¾¹
	add(x, y);
	add(y, x);
}
//ä½¿ç”¨dfsæ±‚æ·±åº¦dep
std::function<void(int, int)>dfs = [&](int u, int fa) -> void{
	dep[u] = dep[fa] + 1;//å½“å‰æ·±åº¦ç­‰äºçˆ¶äº²èŠ‚ç‚¹çš„æ·±åº¦+1
	f[u][0] = fa;//å‘ä¸Šè·³2^0=1ä¸ªæ·±åº¦ä¸ºfa
	for(int i = 1;(1ll << i) <= dep[u];i++)
		f[u][i] = f[f[u][i - 1]][i - 1];//å‘ä¸Šè·³2^(i-1)å±‚çš„ç»“ç‚¹ï¼Œå†å‘ä¸Šè·³2^(i-1)å±‚ï¼Œå³ä¸º2^iå±‚
	for(int i = head[u]; ~i; i = e[i].next)
		if(e[i].to != fa)//å¾€ä¸‹ç»§ç»­dfsæ“ä½œï¼Œé˜²æ­¢å›åˆ°fa
			dfs(e[i].to, u);
};
dfs(s, 0);//è®¾ç«‹ä¸€ä¸ªè™šå‡çš„â€œæ ¹ç»“ç‚¹0â€ï¼Œè®©çœŸæ­£çš„æ ¹ç»“ç‚¹sæ·±åº¦ä¸º1

auto lca = [&](int x, int y) -> int{
	if(dep[x] < dep[y])std::swap(x, y);//æŠŠæ›´æ·±çš„ç»“ç‚¹æ”¾åœ¨å‰é¢
	int tmp = dep[x] - dep[y];//æ±‚æ·±åº¦å·®
	for(int i = 0; (1ll << i) <= tmp; i++)
		if((1ll << i) & tmp)
			x = f[x][i];//ä¸€ç›´å‘ä¸Šè·³ï¼ŒçŸ¥é“xä¸yåŒå±‚
	if(x == y)return x;//å¦‚æœåŒå±‚çš„æ—¶å€™ä¸¤è€…ä¸€æ ·ï¼Œåˆ™å½“å‰ç»“ç‚¹ä¸ºä¹‹å‰ç»“ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
	for(int i = int(log(n) / log(2)); i >= 0; i--)
		if(f[x][i] != f[y][i]){//ä¸€èµ·å‘ä¸Šè·³ç›´åˆ°ä¸¤ä¸ªç‚¹çš„çˆ¶äº²æ˜¯ä¸€æ ·çš„
			x = f[x][i];
			y = f[y][i];
		}
	return f[x][0];//æ­¤æ—¶ä¸¤ä¸ªç»“ç‚¹çš„çˆ¶äº²æ˜¯ä¸€æ ·çš„ï¼Œè¿”å›æ—¶ä¸ºæœ€è¿‘å…¬å…±ç¥–å…ˆ
};
for(int i = 1;i <= m;i++){
	int x, y;
	std::cin >> x >> y;
	std::cout << lca(x, y) << endl;
}
```



##### Tarjanæ±‚LCA

> é€‚ç”¨äº**å·²çŸ¥æ‰€æœ‰æŸ¥è¯¢çš„æ‰¹é‡å¤„ç†**ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n + q)

```cpp
int n, m, s;
std::cin >> n >> m >> s;
//æ­¤å¤„ä½¿ç”¨é‚»æ¥è¡¨å»ºè¾¹ï¼Œansè¡¨ç¤ºç¬¬iæ¬¡æŸ¥è¯¢çš„ç»“æœï¼Œvisè¡¨ç¤ºæŸä¸ªç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
std::vector<int> e[n + 5], ans(m + 5), vis(n + 5);
//æ­¤å¤„å­˜çš„æ˜¯query
std::vector<PII> q[n + 5];
DSU dsu(n);
for(int i = 1;i < n;i++){
	int x, y;
	std::cin >> x >> y;
	e[x].push_back(y);
	e[y].push_back(x);
}
for(int i = 1;i <= m;i++){
	int x, y;
	std::cin >> x >> y;
	if(x == y) ans[i] = x;
	else{
		//å­˜çš„queryæ•°ç»„ï¼Œè¿™é‡Œçš„iä»£è¡¨çš„æ˜¯ç¬¬iæ¬¡æŸ¥è¯¢
		q[x].push_back({y, i});
		q[y].push_back({x, i});
	}
}

std::function<void(int, int)> tarjan = [&](int u, int fa) -> void{
	vis[u] = 1;//æ ‡è®°å½“å‰ç‚¹å·²ç»è¢«è®¿é—®è¿‡
	for(int v : e[u]){
		if(v == fa)continue;
		tarjan(v, u);
    //å°†å­ç»“ç‚¹åˆå¹¶åˆ°å½“å‰ç»“ç‚¹é›†åˆ
    //æ³¨æ„mergeé¡ºåºæ˜¯uåˆå¹¶vï¼Œä¿è¯çˆ¶èŠ‚ç‚¹æ­£ç¡®æ€§ï¼ï¼
		dsu.merge(u, v);
	}
	for(auto [v, idx] : q[u])
		if(vis[v])//å½“å¦ä¸€ä¸ªç»“ç‚¹è¢«è®¿é—®è¿‡æ—¶
      //å½“å‰é›†åˆçš„æ ¹å³ä¸ºLCAï¼ˆå› ä¸ºåˆå¹¶æ–¹å‘æ—¶å‘ä¸Šåˆå¹¶ï¼‰
			ans[idx] = dsu.find(v);
};

tarjan(s, -1);
for(int i = 1;i <= m;i++)
	std::cout << ans[i] << endl;
```



#### ç½‘ç»œæµ

> è¯·å…ˆäº†è§£[ç½‘ç»œ](#network)



##### æœ€å¤§æµ

> å¯¹äºç½‘ç»œæ¥è®²ï¼Œåˆæ³•çš„æµå‡½æ•°æœ‰å¾ˆå¤šï¼Œå…¶ä¸­ä½¿å¾—æ•´ä¸ªç½‘ç»œæµé‡ä¹‹å’Œæœ€å¤§çš„æµå‡½æ•°ç§°ä¸ºç½‘ç»œçš„**æœ€å¤§æµ**ï¼Œæ­¤æ—¶çš„æµé‡å’Œè¢«ç§°ä¸ºç½‘ç»œçš„**æœ€å¤§æµé‡**
>
> ä¾‹é¢˜ï¼š[P3376 ã€æ¨¡æ¿ã€‘ç½‘ç»œæœ€å¤§æµ](https://www.luogu.com.cn/problem/P3376)
>
> [P2740 [USACO4.2] è‰åœ°æ’æ°´Drainage Ditches](https://www.luogu.com.cn/problem/P2740)
>
> å¯¹äºç¨€ç–å›¾ï¼Œä½¿ç”¨EKç®—æ³•æ›´ä¼˜ï¼ˆæ—¶é—´å¤æ‚åº¦$O(nm^2)$ï¼‰ï¼Œå¯¹äºç¨ å¯†å›¾ï¼Œä½¿ç”¨Dinicç®—æ³•æ›´ä¼˜ï¼ˆæ—¶é—´å¤æ‚åº¦$O(n^2m)$ï¼‰



###### Edmonds - Karpå¢å¹¿è·¯ç®—æ³•ï¼ˆEKç®—æ³•ï¼‰

> æ—¶é—´å¤æ‚åº¦ä¸º$O(nm^2)$

æ€æƒ³å°±æ˜¯ä¸æ–­ç”¨BFSå¯»æ‰¾å¢å¹¿è·¯å¹¶ä¸æ–­æ›´æ–°æœ€å¤§æµé‡å€¼ï¼Œç›´åˆ°ç½‘ç»œä¸Šä¸å­˜åœ¨å¢å¹¿è·¯ä¸ºæ­¢ï¼Œå¹¶ä¸”ä¼šå°†**æ— å‘å›¾**çš„æ¯æ¡è¾¹æ‹†æˆ**ä¸¤æ¡æ–¹å‘ç›¸åçš„å•å‘è¾¹**

> æ­¤å¤„çš„å¢å¹¿è·¯å®šä¹‰ä¸ºï¼Œè‹¥ä¸€æ¡ä»Såˆ°Tçš„è·¯å¾„ä¸Š**æ‰€æœ‰è¾¹çš„å‰©ä½™å®¹é‡éƒ½å¤§äº0**ï¼Œåˆ™è¿™æ ·çš„è·¯å¾„ä¸ºå¢å¹¿è·¯
>
> åœ¨BFSå¯»æ‰¾ä¸€æ¡å¢å¹¿è·¯æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘**å‰©ä½™æµé‡ä¸ä¸º0**çš„è¾¹ï¼Œç„¶åæ‰¾åˆ°ä¸€æ¡ä»$S$åˆ°$T$çš„è·¯å¾„ï¼ŒåŒæ—¶è®¡ç®—å‡ºè·¯å¾„ä¸Š**å„è¾¹å‰©ä½™å®¹é‡å€¼çš„æœ€å°å€¼dis**ï¼Œåˆ™ç½‘ç»œçš„æœ€å¤§æµé‡å°±å¯ä»¥å¢åŠ disï¼ˆç»è¿‡çš„æ­£å‘è¾¹å®¹é‡å€¼å…¨éƒ¨å‰ªå»disï¼Œåå‘è¾¹å…¨éƒ¨åŠ ä¸Šdisï¼‰



**ä¸ºä»€ä¹ˆè¦å»ºåå‘è¾¹ï¼Ÿ**

å› ä¸ºå¯èƒ½**ä¸€æ¡è¾¹å¯ä»¥è¢«åŒ…å«äºå¤šæ¡å¢å¹¿è·¯**ï¼Œæ‰€ä»¥ä¸ºäº†å¯»æ‰¾æ‰€æœ‰çš„å¢å¹¿è·¯å¾„æˆ‘ä»¬å°±è¦è®©è¿™ä¸€æ¡è¾¹æœ‰**å¤šæ¬¡è¢«é€‰æ‹©çš„æœºä¼š**ï¼Œç›¸å½“äºç»™ç¨‹åºä¸€æ¬¡**åæ‚”**çš„æœºä¼š



**ä½¿ç”¨â€œæˆå¯¹å­˜å‚¨â€**

å°†æ­£å‘è¾¹å­˜åœ¨**0å’Œ1**ï¼Œ**2å’Œ3**ï¼Œ**4å’Œ5......**

è¿™æ ·å­˜å‚¨èƒ½å¤Ÿä½¿ç”¨**xor1**çš„æ–¹å¼æ‰¾åˆ°å¯¹åº”çš„æ­£å‘è¾¹å’Œåå‘è¾¹



**æ¨¡æ¿**

```cpp
//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå»ºå›¾
struct edge{
    int next, to, val;
};
//nä¸ªç‚¹ï¼Œmæ¡è¾¹ï¼Œsä¸ºæºç‚¹ï¼Œtä¸ºæ±‡ç‚¹ï¼Œç­”æ¡ˆä¸ºans
int n, m, s, t, cnt = 0, ans = 0;
std::cin >> n >> m >> s >> t;
//flowæ˜¯æ¯ä¸ªç‚¹çš„æµé‡ï¼Œpreæ˜¯å‰é©±
std::vector<int> head(n + 5, -1), flow(n + 5), pre(n + 5);
std::vector<edge> e(2 * m + 5);//æ‹†æˆæ–¹å‘ç›¸åçš„ä¸¤æ¡è¾¹ï¼Œæ‰€ä»¥ç©ºé—´è¦ä¸¤å€
std::vector<std::vector<int>> vis(n + 5, std::vector<int>(n + 5, -1));//å¤„ç†é‡è¾¹çš„æƒ…å†µ
//é“¾æ˜Ÿå»ºå›¾è¿‡ç¨‹
auto add = [&](int u, int v, int val) -> void{
  e[cnt].to = v;
	e[cnt].next = head[u];
  e[cnt].val = val;
  vis[u][v] = cnt;//è®°å½•ä¸€ä¸‹ï¼Œå¤„ç†é‡è¾¹çš„æƒ…å†µ
  head[u] = cnt++;
};
for(int i = 1;i <= m;i++){
  int u, v, w;
  std::cin >> u >> v >> w;
  if(vis[u][v] == -1){//è‹¥æ²¡å»ºè¿‡è¾¹ï¼Œåˆ™å­˜å›¾
    add(u, v, w);
    add(v, u, 0);//æ³¨æ„åå‘è¾¹åˆšå¼€å§‹çš„æœ€å¤§å®¹é‡ä¸º0
  }else{//è‹¥å»ºè¿‡è¾¹ï¼Œåˆ™æœ€å¤§å®¹é‡ç›¸åŠ 
    e[vis[u][v]].val += w;//æ³¨æ„ä¸éœ€è¦ç»™åå‘è¾¹åŠ 
  }
}
//bfsæ±‚å¢å¹¿è·¯è¿‡ç¨‹
auto bfs = [&]() -> int{
  std::vector<int> vis(n + 5);
	std::queue<int> q;
	q.push(s);
	vis[s] = 1;
	flow[s] = 1e9;
	while(!q.empty()){
		int u = q.front();
    q.pop();
		for(int i = head[u]; ~i; i = e[i].next){
      if(!e[i].val)continue;//æˆ‘ä»¬åªå…³å¿ƒå‰©ä½™æµé‡ä¸ä¸º0çš„è¾¹
      int v = e[i].to, val = e[i].val;
      if(vis[v])continue;//è‹¥è¿™ä¸€æ¡å¢å¹¿è·¯å·²ç»è¢«è®¿é—®è¿‡ï¼Œåˆ™è·³è¿‡
      flow[v] = std::min(flow[u], val);//æµé‡ä¸ºè¿™æ¡è¾¹çš„æœ€å¤§æµé‡ å’Œ å‰ä¸€ä¸ªç‚¹çš„æµé‡ çš„ æœ€å°å€¼
      pre[v] = i; //è®°å½•å‰é©±ï¼Œæ–¹ä¾¿ä¿®æ”¹è¾¹æƒ    
      q.push(v);   
      vis[v] = 1; 
      if(v == t) return 1;//æˆåŠŸæ‰¾åˆ°å¢å¹¿è·¯            
    }   
  }        
  return 0;    
};
//æ›´æ–°æ‰€ç»è¿‡è¾¹çš„æ­£å‘è¾¹æƒå’Œåå‘è¾¹æƒ
auto update = [&]() -> void{        
  int u = t;        
  while(u != s){            
    int v = pre[u];//æ‰¾å‰é©±            
    e[v].val -= flow[t];//å½“å‰è¾¹èƒ½å®¹çº³çš„å®¹é‡å‡å°            
    e[v ^ 1].val += flow[t];//åå‘è¾¹å®¹çº³çš„å®¹é‡å¢å¤§            
    u = e[v ^ 1].to;//ç»§ç»­èµ°å‰é¢çš„ç‚¹
    //åå‘è¾¹è¦å»çš„ç‚¹å³ä½å‰é¢çš„ç‚¹        
  }        
  ans += flow[t];//ç­”æ¡ˆä¸ºæ¯ä¸€æ¡å¢å¹¿è·¯çš„æœ€å°æµé‡å€¼ä¹‹å’Œ    
};
while(bfs())update();//ç›´åˆ°ç½‘ç»œä¸­ä¸å­˜åœ¨å¢å¹¿è·¯
std::cout << ans << endl;
```



###### Dinicç®—æ³•

> æ—¶é—´å¤æ‚åº¦$O(n^2m)$

éœ€è¦å°†**æ— å‘å›¾**çš„æ¯æ¡è¾¹æ‹†æˆ**ä¸¤æ¡æ–¹å‘ç›¸åçš„å•å‘è¾¹**

EKç®—æ³•**æ¯æ¬¡éƒ½ä¼šéå†æ•´ä¸ªæ®‹é‡ç½‘ç»œ**ï¼Œä½†**åªæ‰¾å‡ºä¸€æ¡å¢å¹¿è·¯**ï¼Œèƒ½å¦ä¸€æ¬¡æ‰¾å¤šæ¡å¢å¹¿è·¯å‘¢ï¼ŸDinicç®—æ³•ä½¿ç”¨äº†åˆ†å±‚å›¾&DFSæ¥å®ç°åŒæ—¶æ±‚å‡ºå¤šæ¡å¢å¹¿è·¯çš„éœ€æ±‚

> åˆ†å±‚å›¾ä¸ºä¸€å¼ **æœ‰å‘æ— ç¯å›¾**ï¼Œè®¾ä»$S$åˆ°xæœ€å°‘éœ€è¦ç»è¿‡çš„è¾¹æ•°ä¸ºå®ƒçš„**å±‚æ¬¡**ï¼Œç”¨$d[x]$è¡¨ç¤ºï¼Œé‚£ä¹ˆåœ¨æ®‹é‡ç½‘ç»œä¸­ï¼Œæ»¡è¶³$d[y]=d[x]+1$çš„è¾¹$(x,y)$æ„æˆçš„å­å›¾è¢«ç§°ä¸º**åˆ†å±‚å›¾**

**å½“å‰å¼§ä¼˜åŒ–**

åœ¨ä¼ ç»ŸDFSä¸­ï¼Œæ¯æ¬¡è®¿é—®èŠ‚ç‚¹æ—¶éƒ½ä¼šä»å¤´åˆ°å°¾éå†è¡¨ã€‚ä½†æŸäº›è¾¹å¯èƒ½åœ¨ä¹‹å‰çš„æœç´¢ä¸­å·²ç»è€—å°½äº†å®¹é‡ï¼ˆå³å‰©ä½™æµé‡ä¸º0ï¼‰ï¼Œé‡å¤æ£€æŸ¥è¿™äº›è¾¹ä¼šæµªè´¹æ—¶é—´ã€‚å½“å‰å¼§ä¼˜åŒ–é€šè¿‡è®°å½•æ¯ä¸ªèŠ‚ç‚¹**å½“å‰åº”æ£€æŸ¥çš„è¾¹**ï¼Œè·³è¿‡æ— æ•ˆè¾¹ï¼Œä»è€Œå‡å°‘å†—ä½™æ“ä½œã€‚



**ä¸ºä»€ä¹ˆè¦å»ºåå‘è¾¹ï¼Ÿ**

å› ä¸ºå¯èƒ½**ä¸€æ¡è¾¹å¯ä»¥è¢«åŒ…å«äºå¤šæ¡å¢å¹¿è·¯**ï¼Œæ‰€ä»¥ä¸ºäº†å¯»æ‰¾æ‰€æœ‰çš„å¢å¹¿è·¯å¾„æˆ‘ä»¬å°±è¦è®©è¿™ä¸€æ¡è¾¹æœ‰**å¤šæ¬¡è¢«é€‰æ‹©çš„æœºä¼š**ï¼Œç›¸å½“äºç»™ç¨‹åºä¸€æ¬¡**åæ‚”**çš„æœºä¼š



**ä½¿ç”¨â€œæˆå¯¹å­˜å‚¨â€**

å°†æ­£å‘è¾¹å­˜åœ¨**0å’Œ1**ï¼Œ**2å’Œ3**ï¼Œ**4å’Œ5......**

è¿™æ ·å­˜å‚¨èƒ½å¤Ÿä½¿ç”¨**xor1**çš„æ–¹å¼æ‰¾åˆ°å¯¹åº”çš„æ­£å‘è¾¹å’Œåå‘è¾¹



**æ¨¡æ¿**

```cpp
//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå»ºå›¾
struct edge{
    int next, to, val;
};
//nä¸ªç‚¹ï¼Œmæ¡è¾¹ï¼Œsä¸ºæºç‚¹ï¼Œtä¸ºæ±‡ç‚¹ï¼Œç­”æ¡ˆä¸ºans
int n, m, s, t, cnt = 0, ans = 0;
std::cin >> n >> m >> s >> t;
//depæ˜¯æ¯ä¸ªç‚¹çš„æ·±åº¦ï¼Œnowæ˜¯å½“å‰å¼§ä¼˜åŒ–
std::vector<int> head(n + 5, -1), dep(n + 5), now(n + 5);
std::vector<edge> e(2 * m + 5);//æ‹†æˆæ–¹å‘ç›¸åçš„ä¸¤æ¡è¾¹ï¼Œæ‰€ä»¥ç©ºé—´è¦ä¸¤å€
//é“¾æ˜Ÿå»ºå›¾è¿‡ç¨‹
auto add = [&](int u, int v, int val) -> void{
  e[cnt].to = v;
	e[cnt].next = head[u];
  e[cnt].val = val;
  head[u] = cnt++;
};
for(int i = 1;i <= m;i++){
  int u, v, w;
  std::cin >> u >> v >> w;
  add(u, v, w);
  add(v, u, 0);
}
//åœ¨æ®‹é‡ç½‘ç»œä¸­æ„é€ åˆ†å±‚å›¾    
auto bfs = [&]() -> int{        
  for(int i = 1;i <= n;i++)dep[i] = 1e9;        
  std::queue<int> q;        
  q.push(s);        
  dep[s] = 0;        
  now[s] = head[s];//åˆå§‹åŒ–å½“å‰å¼§ä¸ºuå¤´æŒ‡é’ˆ       
  while(!q.empty()){            
    int u = q.front();            
    q.pop();           
    for(int i = head[u]; ~i; i = e[i].next){                
      int v = e[i].to, val = e[i].val;                
      //è‹¥æœ‰å‰©ä½™å®¹é‡ä¸”væœªè¢«åˆ†å±‚                
      if(val > 0 && dep[v] == 1e9){                    
        q.push(v);                    
        now[v] = head[v];//åˆå§‹åŒ–vå¾—å½“å‰å¼§                    
        dep[v] = dep[u] + 1;//å±‚æ¬¡+1                    
        if(v == t) return 1;//åˆ°è¾¾æ±‡ç‚¹åˆ™æ„å»ºæˆåŠŸ                
      }            
    }        
  }        
  return 0;    
};
std::function<int(int, int)> dfs = [&](int u, int flow) -> int{        
  if(u == t) return flow; //åˆ°è¾¾æ±‡ç‚¹ï¼Œè¿”å›å¯æ¨é€çš„æµé‡       
  int k, res = 0;//kä¸ºå•æ¡è·¯å¾„æµé‡ï¼Œresä¸ºç´¯ç§¯æµé‡        
  //å¦‚æœè¿˜æœ‰æµé‡        
  for(int i = now[u]; ~i && flow; i = e[i].next){            
    now[u] = i; //æ›´æ–°å½“å‰å¼§æŒ‡é’ˆ            
    int v = e[i].to, val = e[i].val;            
    //è‹¥è¿™ä¸ªç‚¹åœ¨æˆ‘ä¸‹ä¸€å±‚ï¼Œä¸”è¾¹è¿˜æœ‰å‰©ä½™æµé‡            
    if(val > 0 && (dep[v] == dep[u] + 1)){             
      k = dfs(v, std::min(flow, e[i].val));      
      if(!k)dep[v] = 1e9; //å‰ªæï¼šè‹¥èŠ‚ç‚¹æ— æ³•åˆ°è¾¾æ±‡ç‚¹      
      e[i].val -= k; //æ›´æ–°æ­£å‘è¾¹å‰©ä½™å®¹é‡      
      e[i ^ 1].val += k; //æ›´æ–°åå‘è¾¹å‰©ä½™å®¹é‡        
      res += k; //ç´¯åŠ è¯¥èŠ‚ç‚¹è¾“å‡ºçš„æ€»æµé‡               
      flow -= k; //å‡å°‘å‰©ä½™éœ€è¦æ¨é€çš„æµé‡            
    }       
  }        
  return res;   
};    
//æ¯æ¬¡BFSåˆ†å±‚åDFSå¤šè·¯å¢å¹¿    
while(bfs())        
  ans += dfs(s, 1e9);//ä»æºç‚¹æ¨é€æ— é™æµé‡ï¼ˆå®é™…ä¸Šé¦–å…ˆäºè¾¹å®¹é‡ï¼‰    
std::cout << ans << endl;
```



##### æœ€å°è´¹ç”¨æœ€å¤§æµ

> ä¾‹é¢˜ï¼š[P3381 ã€æ¨¡æ¿ã€‘æœ€å°è´¹ç”¨æœ€å¤§æµ](https://www.luogu.com.cn/problem/P3381)

ç»™å®šç½‘ç»œ$D=(V, E, C)$ï¼Œæ¯ä¸€æ¡å¼§$(v_i, v_j)$ä¸Šï¼Œé™¤äº†å·²ç»ç»™çš„æœ€å¤§å®¹é‡$C_{ij}$ä»¥å¤–ï¼Œè¿˜ç»™äº†ä¸€ä¸ªå•ä½æµé‡çš„è´¹ç”¨$cost(v_i, v_j) \geq 0$ã€‚æœ€å°è´¹ç”¨æœ€å¤§æµé—®é¢˜å³å…ˆä¿è¯**æœ€å¤§æµ $f$ **çš„å‰æä¸‹ï¼Œæµçš„**æ€»è¾“é€è´¹ç”¨æœ€å°**



###### SPFA+EKå®ç°

```cpp
//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå»ºå›¾
struct edge{
    int next, to, flow, cost;
};
//nä¸ªç‚¹ï¼Œmæ¡è¾¹ï¼Œsä¸ºæºç‚¹ï¼Œtä¸ºæ±‡ç‚¹ï¼Œæœ€å¤§æµä¸ºmaxFlowï¼Œæœ€å°èŠ±è´¹ä¸ºminCost
int n, m, s, t, cnt = 0, maxFlow = 0, minCost = 0;    
std::cin >> n >> m >> s >> t;    
//flowæ˜¯æ¯ä¸ªç‚¹çš„æµé‡ï¼Œpreæ˜¯å‰é©±ï¼Œcostæ˜¯èŠ±è´¹ 
std::vector<int> head(n + 5, -1), flow(n + 5), pre(n + 5), cost(n + 5), vis(n + 5);
std::vector<edge> e(2 * m + 5);//æ‹†æˆæ–¹å‘ç›¸åçš„ä¸¤æ¡è¾¹ï¼Œæ‰€ä»¥ç©ºé—´è¦ä¸¤å€    
//é“¾æ˜Ÿå»ºå›¾è¿‡ç¨‹    
auto add = [&](int u, int v, int flow, int cost) -> void{        
  e[cnt].to = v;        
  e[cnt].next = head[u];        
  e[cnt].flow = flow;        
  e[cnt].cost = cost;       
  head[u] = cnt++;    
};    
for(int i = 1;i <= m;i++){        
  int u, v, w, c;        
  std::cin >> u >> v >> w >> c;        
  add(u, v, w, c);        
  add(v, u, 0, -c);//æ³¨æ„åå‘è¾¹åˆšå¼€å§‹çš„æœ€å¤§å®¹é‡ä¸º0ï¼ŒèŠ±è´¹ä¸º-c    
}    
//spfaæ±‚å¢å¹¿è·¯   
auto spfa = [&]() -> bool{    
  for(int i = 1;i <= n;i++)cost[i] = 1e18;  
  std::queue<int> q;  
  q.push(s);  
  cost[s] = 0;//åˆå§‹åŒ–æºç‚¹èŠ±è´¹ä¸º0  
  flow[s] = 1e18;//åˆå§‹åŒ–æºç‚¹ä¸ºæ— é™æµé‡ï¼ˆå®é™…ä¸Šå—å…¶ä»–è¾¹é™åˆ¶ï¼‰  
  pre[t] = -1;//åˆå§‹åŒ–æ±‡ç‚¹çš„å‰é©±ä¸º-1  
  while(!q.empty()){  
    int u = q.front();    
    q.pop();    
    vis[u] = 0;    
    for(int i = head[u]; ~i; i = e[i].next){    
      int v = e[i].to;      
      //å¦‚æœè¿˜æœ‰å‰©ä½™å®¹é‡ï¼Œå¹¶ä¸”å­˜åœ¨æ›´çŸ­è·¯      
      if(e[i].flow > 0 && cost[v] > cost[u] + e[i].cost){      
        cost[v] = cost[u] + e[i].cost;//æ›´æ–°èŠ±è´¹æ•°ç»„        
        pre[v] = i;//æ›´æ–°å‰é©±        
        flow[v] = std::min(flow[u], e[i].flow);//æ›´æ–°å‰©ä½™å®¹é‡        
        if(!vis[v]){        
          vis[v] = 1;          
          q.push(v);          
        }        
      }      
    }    
  }  
  return pre[t] != -1;//è‹¥æ±‡ç‚¹å‰é©±ä¸ä¸º-1ï¼Œåˆ™æ‰¾åˆ°äº†å¢å¹¿è·¯
};
//æœ€å°è´¹ç”¨æœ€å¤§æµ
auto MCMF = [&]() -> void{
  while(spfa()){  
    int u = t;    
    maxFlow += flow[t];    
    minCost += flow[t] * cost[t];    
    while(u != s){    
      int v = pre[u];//æ‰¾å‰é©±                  
      e[v].flow -= flow[t];//å½“å‰è¾¹èƒ½å®¹çº³çš„å®¹é‡å‡å°                  
      e[v ^ 1].flow += flow[t];//åå‘è¾¹å®¹çº³çš„å®¹é‡å¢å¤§                  
      u = e[v ^ 1].to;//ç»§ç»­èµ°å‰é¢çš„ç‚¹      
      //åå‘è¾¹è¦å»çš„ç‚¹å³ä½å‰é¢çš„ç‚¹      
    }    
  } 
};
MCMF();
std::cout << maxFlow << " " << minCost << endl;
```



###### Dijkstra+EKå®ç°

[Dijkstraç®—æ³•](#Dijkstra)æ— æ³•å¤„ç†**è´Ÿæƒè¾¹**ï¼Œé‚£ä¹ˆç½‘ç»œæµè¿›è¡Œæ‹†è¾¹çš„æ—¶å€™ï¼Œä¼šå‡ºç°è´Ÿè¾¹ï¼Œç›´æ¥ä½¿ç”¨Dijkstraä¼šå¤±æ•ˆã€‚é‚£ä¹ˆå—åˆ°[Johnsonç®—æ³•](#Johnson)çš„å¯å‘ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒæ•´è¾¹æƒæ¶ˆé™¤è´Ÿæƒè¾¹ï¼ŒåŒæ—¶ä¿è¯æœ€çŸ­è·¯å¾„çš„ç›¸å¯¹å…³ç³»ä¸å˜ã€‚

> è¦æ˜¯ä¸ç†è§£è¿™é‡Œï¼Œè¯·è‡ªè¡Œè·³è½¬ **å…¨æºæœ€çŸ­è·¯ Johnsonç®—æ³•** å¤„è¿›è¡Œå­¦ä¹ 

åˆå§‹åŠ¿èƒ½è®¡ç®—ï¼š

ä½¿ç”¨[SPFAç®—æ³•](#SPFA)é¢„å¤„ç†å‡ºåˆå§‹åŠ¿èƒ½æ•°ç»„$h$ï¼Œå…¶ä¸­$h[u]$è¡¨ç¤ºä»æºç‚¹$s$åˆ°èŠ‚ç‚¹$u$çš„æœ€çŸ­è·¯å¾„è´¹ç”¨ã€‚æ­¤æ—¶ï¼Œæ‰€æœ‰è¾¹çš„è°ƒæ•´åè´¹ç”¨ä¸ºï¼š
$$
adjusted\_cost(u \rightarrow v) = cost(u \rightarrow v) + h[u] - h[v]
$$
æ¯æ¬¡é€šè¿‡Dijkstraæ‰¾åˆ°å¢å¹¿è·¯å¾„åï¼Œæ›´æ–°åŠ¿èƒ½æ•°ç»„ï¼š
$$
h[u] = h[u] + dis[u]
$$
å…¶ä¸­$dis[u]$æ˜¯å½“å‰è°ƒæ•´åçš„è´¹ç”¨ä¸‹çš„æœ€çŸ­è·ç¦»ï¼Œè¿™ä¿è¯åç»­è¾¹æƒè°ƒæ•´åä»ä¸ºè´Ÿã€‚



**æ¨¡æ¿**

```cpp
//æ­¤å¤„ä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿå­˜å›¾
struct edge{
    int to, next, flow, cost;
};
//æ­¤å¤„æ˜¯é‡è½½è¿ç®—ç¬¦
class cmp{
public:    
    bool operator()(const PII &x, const PII &y){  
        return x.second > y.second;    
        //å› ä¸ºé‡è½½çš„æ˜¯å †ï¼Œæ‰€ä»¥æ¯”è¾ƒå‡½æ•°è¦ä»å¤§åˆ°å°ï¼Œè¿™æ ·è¾“å‡ºçš„ç»“æœä¸ºä»å°åˆ°å¤§    
    }
};
//nä¸ªç‚¹ï¼Œmæ¡è¾¹ï¼Œæºç‚¹ä¸ºsï¼Œæ±‡ç‚¹ä¸ºtï¼Œæœ€å°èŠ±è´¹ä¸ºminCostï¼Œæœ€å¤§æµä¸ºmaxFlow    
int n, m, s, t, minCost = 0, maxFlow = 0, cnt = 0;
std::cin >> n >> m >> s >> t;
//hä¸ºåŠ¿èƒ½ï¼Œpreä¸ºå‰é©±
std::vector<int> head(n + 5, -1), h(n + 5), pre(n + 5);
std::vector<edge> e(2 * m + 5);
auto add = [&](int u, int v, int flow, int cost) -> void{
  e[cnt].to = v;  
  e[cnt].next = head[u];  
  e[cnt].flow = flow;  
  e[cnt].cost = cost;  
  head[u] = cnt++;  
};
for(int i = 1;i <= m;i++){
  int u, v, w, c;  
  std::cin >> u >> v >> w >> c;  
  add(u, v, w, c);  
  add(v, u, 0, -c);//æ³¨æ„åå‘è¾¹  
}
auto MCMF = [&]() -> void{        
  while(1){  
    //æ­¤å¤„çš„PIIå­˜æ”¾çš„æ˜¯{u, dis}ï¼Œå³{ç‚¹ï¼Œè·ç¦»}    
    std::priority_queue<PII, std::vector<PII>, cmp> q;    
    //costä¸ºèŠ±è´¹æ•°ç»„ï¼Œvisä¸ºæ˜¯å¦å·²ç»èµ°è¿‡    
    std::vector<int> cost(n + 5, 1e9), vis(n + 5);    
    cost[s] = 0;    
    q.push({s, 0});    
    //Dijkstraè¿‡ç¨‹    
    while(!q.empty()){    
      auto [u, c] = q.top();      
      q.pop();      
      vis[u] = 1;      
      for(int i = head[u]; ~i; i = e[i].next){      
        //æ­¤å¤„çš„valæ˜¯åŠ ä¸ŠåŠ¿èƒ½åçš„è¾¹æƒ        
        int v = e[i].to, val = e[i].cost + h[u] - h[v];        
        //å¦‚æœè¿˜æœ‰å‰©ä½™å®¹é‡ï¼Œå¹¶ä¸”å½“å‰èŠ±è´¹å¤§äºä¹‹å‰çš„èŠ±è´¹åŠ ä¸Š åŠ ä¸ŠåŠ¿èƒ½åçš„è¾¹æƒ        
        if(e[i].flow > 0 && cost[v] > c + val){        
          cost[v] = c + val;//æ›´æ–°costæ•°ç»„          
          pre[v] = i;//è®°å½•å‰é©±          
          q.push({v, cost[v]});          
        }        
      }      
    }    
    //è‹¥æ²¡æœ‰åˆ°è¾¾æ±‡ç‚¹ï¼Œåˆ™è¡¨ç¤ºæ²¡æœ‰æ®‹é‡ç½‘ç»œï¼Œé€€å‡ºå‡½æ•°    
    if(cost[t] == 1e9) return ;    
    //æ›´æ–°åŠ¿èƒ½    
    for(int i = 1; i <= n; i++)    
      if(cost[i] != 1e9)h[i] += cost[i];      
    //è®¡ç®—å¢å¹¿æµé‡    
    int curFlow = 1e9;    
    for(int u = t; u != s; u = e[pre[u] ^ 1].to)    
      curFlow = std::min(curFlow, e[pre[u]].flow);
    //æ›´æ–°æœ€å¤§æµå’Œæœ€å°èŠ±è´¹
    maxFlow += curFlow;    
    minCost += curFlow * h[t]; //æ­¤å¤„çš„h[t]å·²ç»åŒ…å«äº†è°ƒæ•´åçš„æ€»è´¹ç”¨    
    //æ›´æ–°ç½‘ç»œ    
    for(int u = t; u != s; u = e[pre[u] ^ 1].to){    
      e[pre[u]].flow -= curFlow;      
      e[pre[u] ^ 1].flow += curFlow;      
    }    
  }   
};
MCMF();
std::cout << maxFlow << " " << minCost << endl;
```



### æ•°æ®ç»“æ„

<span id = "dsu"></span>

#### å¹¶æŸ¥é›†

> ä¾‹é¢˜ï¼š[P1536 æ‘æ‘é€š](https://www.luogu.com.cn/problem/P1536)

```cpp
class DSU{
private:
	int n;
	std::vector<int> f, sz;
public:
	DSU(int x){
		n = x;
		f.resize(n + 5);
		sz.resize(n + 5, 1);
		for(int i = 1;i <= n;i++)f[i] = i;
	}
	
	int find(int x){
		if(f[x] != x)f[x] = find(f[x]);
		return f[x];
	}
	//åˆå¹¶x y
	void merge(int x, int y){
		int cx = find(x), cy = find(y);
		f[cy] = cx;
		sz[cy] += sz[cx];
	}
	//åˆ¤æ–­x yæ˜¯å¦å±äºä¸€ä¸ªè”é€šå—
	bool same(int x, int y){
		return find(x) == find(y);
	}
	//åˆ¤æ–­æŸä¸ªè”é€šå—æœ‰å‡ ä¸ªèŠ‚ç‚¹
	int get_size(int x){
		return sz[x];
	}
};
```



#### çº¿æ®µæ ‘

<span id="SegmentTree"></span>

##### SegmentTreeï¼ˆä¸å¸¦LazyTagï¼‰

###### Ice'sçº¿æ®µæ ‘æ¨¡æ¿ä½¿ç”¨æ³¨æ„äº‹é¡¹

<span id="SegmentTree_notice"></span>

æ³¨æ„æ­¤çº¿æ®µæ ‘ä¸‹æ ‡**ä»1å¼€å§‹(1-based)**ï¼Œå¹¶ä¸”**æ“ä½œåŒºé—´ä¸ºå·¦é—­å³é—­åŒºé—´**ï¼ï¼ï¼

æœ‰ä¸¤ç§æ„é€ æ–¹å¼ï¼Œæ–¹å¼ä¸€ä¸ºç›´æ¥æŒ‡å®šå¤§å°

```cpp
SegmentTree<Info> sgt(n);
```

è°ƒç”¨çš„æ„é€ å‡½æ•°åŸå‹ä¸º

```cpp
SegmentTree(int _n, Info _v = Info()){
	init(_n, _v);
}
```

æ–¹å¼äºŒä¸ºä¼ å…¥åˆå§‹åŒ–æ•°ç»„ä»¥åŠå¤§å°ï¼ˆåˆå§‹åŒ–æ•°ç»„é•¿åº¦ä»»æ„ï¼Œä½†æ˜¯**ä¸€å®šè¦ä¿è¯æ•°æ®å­˜åœ¨1-nï¼ï¼**

```cpp
std::vector<Info> a(n + 5);
for(int i = 1;i <= n;i++)
  //æ­¤å¤„å¯¹aè¿›è¡Œè¾“å…¥
SegmentTree<Info> sgt(n, a);
```

è°ƒç”¨çš„æ„é€ å‡½æ•°åŸå‹ä¸º

```cpp
template<class T>
SegmentTree(int _n, std::vector<T> _init){
	init(_n, _init);
}
```

initå‡½æ•°ä¸º

```cpp
template<class T>
void init(int _n, std::vector<T> _init){
	n = _n;
	info.resize(4 * n + 5, Info());

	std::function<void(int, int, int)>build = [&](int k, int l, int r) -> void{
		if(l == r){
			info[k] = _init[l];
			return ;
		}
		int mid = (l + r) >> 1;
		build(lc(k), l, mid);
		build(rc(k), mid + 1, r);
		pushup(k);
	};

	build(1, 1, n);
}
```

ä¸Šè¿°ä¸¤ç§æ–¹æ³•ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°éƒ½ä¸ºnï¼ŒæŒ‡çš„æ˜¯çº¿æ®µæ ‘å¤„ç†çš„åŒºé—´æ˜¯**1ï½n**



###### çº¿æ®µæ ‘æ¨¡æ¿

```cpp
template<class Info>
class SegmentTree{
	#define lc(x) (x << 1)
	#define rc(x) (x << 1 | 1)
private:
	int n;
	std::vector<Info> info;
public:
	SegmentTree(int _n, Info _v = Info()){
		init(_n, _v);
	}

	template<class T>
	SegmentTree(int _n, std::vector<T> _init){
		init(_n, _init);
	}

	//è‹¥_initå¤§å°ä¸ºn+5ï¼Œåˆ™éœ€è¦ä¼ å…¥é¢˜ç›®é•¿åº¦nï¼Œä»¥åŠ_init
	template<class T>
	void init(int _n, std::vector<T> _init){
		n = _n;
		info.resize(4 * n + 5, Info());

		std::function<void(int, int, int)>build = [&](int k, int l, int r) -> void{
			if(l == r){
				info[k] = _init[l];
				return ;
			}
			int mid = (l + r) >> 1;
			build(lc(k), l, mid);
			build(rc(k), mid + 1, r);
			pushup(k);
		};

		build(1, 1, n);
	}

	//å¯ä»¥ç›´æ¥ä¼ å…¥nçš„å¤§å°
	void init(int _n, Info _v = Info()){
		init(_n, std::vector<Info>(_n + 5, _v));
	}

	void pushup(int k){
		info[k] = info[lc(k)] + info[rc(k)];
	}

	void update(int k, int l, int r, int x, const Info &v){
		if(l == r){
			info[k] = v;
			return ;
		}
		int mid = (l + r) >> 1;
		if(x <= mid)update(lc(k), l, mid, x, v);
		else update(rc(k), mid + 1, r, x, v);
		pushup(k);
	}

	void update(int k, const Info &v){
		update(1, 1, n, k, v);
	}

	Info query(int k, int l, int r, int x, int y){
		if(l > y || r < x)return Info();
		if(x <= l && r <= y)return info[k];
		int mid = (l + r) >> 1;
		return query(lc(k), l, mid, x, y) + query(rc(k), mid + 1, r, x, y);
	}

	Info query(int l, int r){
		return query(1, 1, n, l, r);
	}

	#undef lc(k)
	#undef rc(k)
};

struct Info {
	//åœ¨æ­¤å¤„å­˜æ”¾å˜é‡
};

Info operator+(const Info &a, const Info &b){
	Info c;
  //åœ¨æ­¤å¤„é‡è½½è§„åˆ™
  return c;
}
```

> åœ¨ä½¿ç”¨æ­¤çº¿æ®µæ ‘å‰ï¼Œè¯·ç¡®ä¿ä½ å·²ç»çœ‹è¿‡äº†[Ice'sçº¿æ®µæ ‘æ¨¡æ¿ä½¿ç”¨æ³¨æ„äº‹é¡¹](#SegmentTree_notice)
>
> > å³æ­¤Tagçš„SegmentTreeä¸‹é¢çš„ç°è‰²æ–‡å­—éƒ¨åˆ†ï¼Œè¿™éƒ¨åˆ†è®²äº†æ­¤çº¿æ®µæ ‘åˆå§‹åŒ–çš„æ–¹å¼ä»¥åŠä¼ å…¥çš„å‚æ•°ï¼Œå¹¶ä¸”è¯´æ˜äº†æ­¤çº¿æ®µæ ‘ä¸º**1-based**



###### Infoç±»å‹å˜é‡çš„ä¹¦å†™è§„åˆ™ä»¥åŠInfoé‡è½½è¿ç®—ç¬¦çš„æ–¹æ³•

Infoç»“æ„ä½“å†…å®šä¹‰çš„ä¸ºä½ æƒ³è¦çº¿æ®µæ ‘èƒ½æ“ä½œçš„å˜é‡ï¼Œä¾‹å¦‚åŒºé—´å…ƒç´ å’Œsumï¼Œå…ƒç´ åŒºé—´çš„æœ€å¤§å€¼mxï¼ŒåŒºé—´æœ€å°å€¼mnç­‰

Infoé‡è½½çš„è¿ç®—ç¬¦å³ä½ å¸Œæœ›**pushup**çš„è§„åˆ™

ä¾‹å¦‚å¸¸è§„çº¿æ®µæ ‘å½“ä¸­çš„

```cpp
struct Node{
  int sum, mx, mn;
}t[maxn * 4];
//....
void pushup(int k){
  t[k].sum = t[k << 1].sum + t[k << 1 | 1].sum;
  t[k].mx = std::max(t[k << 1].mx, t[k << 1 | 1].mx);
  t[k].mn = std::min(t[k << 1].mn, t[k << 1 | 1].mn);
}
```

åœ¨æ­¤æ¿å­ä¸­éœ€è¦è¿™æ ·å†™ï¼š

```cpp
struct Info{
  int sum, mx, mn;
  Info(): sum(0), mx(0), mn(0) {}
  Info(int x): sum(x), mx(x), mn(x) {}
};

Info operator+(const Info &a, const Info &b){
  Info c;
  c.sum = a.sum + b.sum;
  c.mx = std::max(a.mx, b.mx);
  c.mn = std::min(a.mn, b.mn);
  return c;
}
```



###### updateå‡½æ•°ï¼ˆå•ç‚¹ä¿®æ”¹ï¼‰

<span id="segment_tree_update"></span>

å…¶ä¸­ï¼Œ**updateå‡½æ•°**ä¸º**å•ç‚¹**ä¿®æ”¹ï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ–¹å¼

ç¬¬ä¸€ç§ï¼Œç›´æ¥æŒ‡å®šéœ€è¦æ“ä½œçš„**ä¸‹æ ‡x(1-based)**å’Œéœ€è¦**ä¿®æ”¹ä¸ºçš„Info_valï¼ˆä¸æ˜¯ç›¸åŠ ï¼Œè€Œæ˜¯ç›´æ¥ä¿®æ”¹æˆï¼‰**

```cpp
SegmentTree<Info> sgt(n);
sgt.update(index, Info_val);
```

**å¦‚æœæƒ³è¦ç›¸åŠ ï¼Œä¾‹å¦‚æƒ³è¦å°†indexçš„å€¼åŠ ä¸Šyï¼Œåˆ™éœ€è¦å¦‚æ­¤æ“ä½œï¼š**

```cpp
struct Info{
  //....
  Info(int x = 0): x(x) {}
}
update(index, Info(a[index].val += val));
```

ç¬¬äºŒç§ï¼ŒæŒ‰ç…§å¸¸è§„çº¿æ®µæ ‘çš„updateï¼Œä¼ å…¥æ ¹ï¼Œçº¿æ®µæ ‘å·¦å³åŒºé—´ï¼Œéœ€è¦ä¿®æ”¹çš„ä¸‹æ ‡ï¼Œéœ€è¦**ä¿®æ”¹ä¸ºçš„Info_val**

```cpp
SegmentTree<Info> sgt(n);
sgt.update(1, 1, n, index, Info_val);
```

è‹¥æƒ³æƒ³åŠ ï¼Œåˆ™æŒ‰ç…§ä¸Šé¢çš„æ–¹æ³•è¿›è¡Œæ“ä½œ



###### queryå‡½æ•°ï¼ˆåŒºé—´æŸ¥è¯¢ï¼‰

å¯¹äº**query**å‡½æ•°ï¼Œå¯ä»¥è¿›è¡ŒåŒºé—´æŸ¥è¯¢ï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ–¹å¼

ç¬¬ä¸€ç§ï¼Œç›´æ¥æŒ‡å®šéœ€è¦æŸ¥è¯¢çš„å·¦å³åŒºé—´lï¼Œrï¼Œè¿”å›**Infoç±»å‹å˜é‡**

```cpp
SegmentTree<Info> sgt(n);
Info ans = sgt.query(l, r);
```

ç¬¬äºŒç§ï¼ŒæŒ‰ç…§å¸¸è§„çº¿æ®µæ ‘çš„queryï¼Œä¼ å…¥æ ¹ï¼Œçº¿æ®µæ ‘å·¦å³åŒºé—´ï¼Œéœ€è¦æŸ¥è¯¢çš„å·¦å³åŒºé—´lï¼Œrï¼Œè¿”å›**Infoç±»å‹å˜é‡**

```cpp
SegmentTree<Info> sgt(n);
Info ans = sgt.query(1, 1, n, l, r);
```



###### ä½¿ç”¨ç¤ºä¾‹

ä¾‹å¦‚æˆ‘éœ€è¦ä¿®æ”¹å•ç‚¹çš„å€¼ï¼ŒæŸ¥è¯¢åŒºé—´gcdä»¥åŠåŒºé—´å’Œï¼Œç¤ºä¾‹ä¸ºï¼š

```cpp
struct Info {
	int x, d;
	Info(int x = 0) : x(x), d(x) {}
};
 
Info operator+(const Info &a, const Info &b){
	Info c;
	c.x = a.x + b.x;
	c.d = gcd(a.d, b.d);
	return c;
}
 
std::vector<Info> a(n + 5);
for(int i = 1;i <= n;i++){
	int x;
	std::cin >> x;
	a[i] = Info(x);
}
SegmentTree<Info> sgt(n, a);
while(m--){
//æ­¤å¤„å½“optä¸º1æ—¶ï¼Œå‘ç¬¬xä½çš„æ•°å­—+y
//å½“optä¸º2æ—¶ï¼ŒæŸ¥è¯¢[x, y]çš„gcdå’Œå…ƒç´ å’Œ
	int opt, x, y;
	std::cin >> opt >> x >> y;
	if(opt == 1){
		sgt.update(x, Info(a[x].x += y));
	}else std::cout << sgt.query(x, y).x << " " << sgt.query(x, y).d << endl;
}
```



##### LazySegmentTreeï¼ˆå¸¦LazyTagï¼‰

###### Ice'sæ‡’æ ‡è®°çº¿æ®µæ ‘æ¨¡æ¿ä½¿ç”¨æ³¨æ„äº‹é¡¹

<span id="Lazy_SegmentTree_notice"></span>

æ³¨æ„æ­¤çº¿æ®µæ ‘ä¸‹æ ‡**ä»1å¼€å§‹(1-based)**ï¼Œå¹¶ä¸”**æ“ä½œåŒºé—´ä¸ºå·¦é—­å³é—­åŒºé—´**ï¼ï¼ï¼

æœ‰ä¸¤ç§æ„é€ æ–¹å¼ï¼Œæ–¹å¼ä¸€ä¸ºç›´æ¥æŒ‡å®šå¤§å°

```cpp
LazySegmentTree<Info, Tag> lsgt(n);
```

è°ƒç”¨çš„æ„é€ å‡½æ•°åŸå‹ä¸º

```cpp
LazySegmentTree(int _n, Info _v = Info()){
	init(_n, _v);
}
```

æ–¹å¼äºŒä¸ºä¼ å…¥åˆå§‹åŒ–æ•°ç»„ä»¥åŠå¤§å°ï¼ˆåˆå§‹åŒ–æ•°ç»„é•¿åº¦ä»»æ„ï¼Œä½†æ˜¯**ä¸€å®šè¦ä¿è¯æ•°æ®å­˜åœ¨1-nï¼ï¼**

```cpp
std::vector<Info> a(n + 5);
for(int i = 1;i <= n;i++)
//æ­¤å¤„å¯¹aè¿›è¡Œè¾“å…¥
LazySegmentTree<Info, Tag> lsgt(n, a);
```

è°ƒç”¨çš„æ„é€ å‡½æ•°åŸå‹ä¸º

```cpp
template<class T>
LazySegmentTree(int _n, std::vector<T> _init){
	init(_n, _init);
}
```

initå‡½æ•°ä¸º

```cpp
template<class T>
void init(int _n, std::vector<T> _init){
	n = _n;
	info.resize(4 * n + 5, Info());
	tag.resize(4 * n + 5, Tag());
	std::function<void(int, int, int)>build = [&](int k, int l, int r) -> void{
		if(l == r){
			info[k] = Info(_init[l], l, l);
			return ;
		}
		int mid = (l + r) >> 1;
		build(lc(k), l, mid);
		build(rc(k), mid + 1, r);
		pushup(k);
	};
  
	build(1, 1, n);
}
```

ä¸Šè¿°ä¸¤ç§æ–¹æ³•ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°éƒ½ä¸ºnï¼ŒæŒ‡çš„æ˜¯çº¿æ®µæ ‘å¤„ç†çš„åŒºé—´æ˜¯**1ï½n**



###### æ‡’çº¿æ®µæ ‘æ¿å­

```cpp
template<class Info, class Tag>
class LazySegmentTree{
	#define lc(x) (x << 1)
	#define rc(x) (x << 1 | 1)
private:
	int n;
	std::vector<Info> info;
	std::vector<Tag> tag;
public:
	LazySegmentTree(int _n, Info _v = Info()){
		init(_n, _v);
	}

	template<class T>
	LazySegmentTree(int _n, std::vector<T> _init){
		init(_n, _init);
	}

	//è‹¥_initå¤§å°ä¸ºn+5ï¼Œåˆ™éœ€è¦ä¼ å…¥é¢˜ç›®é•¿åº¦nï¼Œä»¥åŠ_init
	template<class T>
	void init(int _n, std::vector<T> _init){
		n = _n;
		info.resize(4 * n + 5, Info());
		tag.resize(4 * n + 5, Tag());
		std::function<void(int, int, int)>build = [&](int k, int l, int r) -> void{
			if(l == r){
				info[k] = _init[l];
				return ;
			}
			int mid = (l + r) >> 1;
			build(lc(k), l, mid);
			build(rc(k), mid + 1, r);
			pushup(k);
		};

		build(1, 1, n);
	}

	//å¯ä»¥ç›´æ¥ä¼ å…¥nçš„å¤§å°
	void init(int _n, Info _v = Info()){
		init(_n, std::vector<Info>(_n + 5, _v));
	}

	void pushup(int k){
		info[k] = info[lc(k)] + info[rc(k)];
	}

	void apply(int k, const Tag &v){
		info[k].apply(v);
		tag[k].apply(v);
	}

	void pushdown(int k){
		apply(lc(k), tag[k]);
		apply(rc(k), tag[k]);
		tag[k] = Tag();
	}

	//å•ç‚¹ä¿®æ”¹
	void update(int k, int l, int r, int x, const Info &v){
		if(l == r){
			info[k] = v;
			return ;
		}
		int mid = (l + r) >> 1;
		pushdown(k);
		if(x <= mid)update(lc(k), l, mid, x, v);
		else update(rc(k), mid + 1, r, x, v);
		pushup(k);
	}

	void update(int k, const Info &v){
		update(1, 1, n, k, v);
	}

	Info query(int k, int l, int r, int x, int y){
		if(l > y || r < x)return Info();
		if(x <= l && r <= y)return info[k];
		int mid = (l + r) >> 1;
		pushdown(k);
		return query(lc(k), l, mid, x, y) + query(rc(k), mid + 1, r, x, y);
	}

	Info query(int l, int r){
		return query(1, 1, n, l, r);
	}

	void Apply(int k, int l, int r, int x, int y, const Tag &v){
		if(l > y || r < x)return ;
		if(x <= l && r <= y){
			apply(k, v);
			return ;
		}
		int mid = (l + r) >> 1;
		pushdown(k);
		Apply(lc(k), l, mid, x, y, v);
		Apply(rc(k), mid + 1, r, x, y, v);
		pushup(k);
	}

	void Apply(int l, int r, const Tag &v){
		return Apply(1, 1, n, l, r, v);
	}

	#undef lc(k)
	#undef rc(k)
};

struct Tag{
	//å®šä¸‹è¦æ”¾ä»€ä¹ˆæ ‡è®°
	void apply(Tag t){
		//æ€ä¹ˆç”¨çˆ¶èŠ‚ç‚¹çš„æ ‡è®°æ›´æ–°å„¿å­çš„æ ‡è®°
	}
};

struct Info {
	//åœ¨æ­¤å¤„å­˜æ”¾å˜é‡
	void apply(Tag t){
		//æ€ä¹ˆç”¨çˆ¶èŠ‚ç‚¹çš„æ ‡è®°æ›´æ–°å„¿å­å­˜å‚¨çš„ä¿¡æ¯
	}
};

Info operator+(const Info &a, const Info &b){
	Info c;
  //åœ¨æ­¤å¤„é‡è½½è§„åˆ™
  return c;
}
```

> åœ¨ä½¿ç”¨æ­¤çº¿æ®µæ ‘å‰ï¼Œè¯·ç¡®ä¿ä½ å·²ç»çœ‹è¿‡äº†[Ice'sæ‡’æ ‡è®°çº¿æ®µæ ‘æ¨¡æ¿ä½¿ç”¨æ³¨æ„äº‹é¡¹](#Lazy_SegmentTree_notice)
>
> > å³æ­¤Tagçš„LazySegmentTreeä¸‹é¢çš„ç°è‰²æ–‡å­—éƒ¨åˆ†ï¼Œè¿™éƒ¨åˆ†è®²äº†æ­¤çº¿æ®µæ ‘åˆå§‹åŒ–çš„æ–¹å¼ä»¥åŠä¼ å…¥çš„å‚æ•°ï¼Œå¹¶ä¸”è¯´æ˜äº†æ­¤çº¿æ®µæ ‘ä¸º**1-based**
>
> æ­¤æ‡’çº¿æ®µæ ‘ä»ç„¶ä¿ç•™äº†å•ç‚¹ä¿®æ”¹ï¼Œå…¶ä¸­**updateå‡½æ•°**ä¸º**å•ç‚¹**ä¿®æ”¹ï¼Œä½¿ç”¨æ–¹å¼ä¸ä¸Šé¢çš„[çº¿æ®µæ ‘ä½¿ç”¨æ–¹å¼](#segment_tree_update)ä¸€æ ·



###### Infoå˜é‡ä»¥åŠTagå˜é‡çš„ä¹¦å†™è§„åˆ™ï¼Œä»¥åŠInfoè¿ç®—ç¬¦é‡è½½çš„ä¹¦å†™è§„åˆ™

Infoé‡è½½çš„è¿ç®—ç¬¦å³ä½ å¸Œæœ›**pushup**çš„è§„åˆ™

Tagç»“æ„ä½“ä¸­ï¼Œé‡è½½çš„applyå‡½æ•°ä¸ºä½ å¸Œæœ›**pushdown**çš„è§„åˆ™

Infoç»“æ„ä½“ä¸­ï¼Œé‡è½½çš„applyå‡½æ•°ä¸ºä½ å¸Œæœ›**pushdown**çš„è§„åˆ™

å¹¶ä¸”Tagå’ŒInfoç»“æ„é¢˜ä¸­é‡è½½çš„applyå‡½æ•°ï¼Œæ˜¯ä»¥**å­ç»“ç‚¹**ä¸ºå½“å‰å˜é‡(this)ï¼Œ**çˆ¶ç»“ç‚¹**ä¸ºä¼ å…¥çš„Tag t

ä¾‹å¦‚å¯¹äºå¸¸è§„çº¿æ®µæ ‘ï¼Œsumä¸ºåŒºé—´å’Œï¼Œaddä¸ºåŠ çš„**tag**

```cpp
struct Node{
  int l, r, add, sum;
}t[maxn * 4];
void pushup(int k){
  t[k].sum = t[k << 1].sum + t[k << 1 | 1].sum;
}
void pushdown(int k){
  t[k << 1].sum += t[k << 1].add * (t[k << 1].r - t[k << 1].l + 1);
  t[k << 1].add += t[k].add;
  t[k << 1 | 1].sum += t[k << 1 | 1].add * (t[k << 1 | 1].r - t[k << 1 | 1].l + 1);
  t[k << 1 | 1].add += t[k].add;
  t[k].tag = 0;
}
```

åœ¨æ­¤æ¿å­ä¸­ï¼Œåˆ™éœ€è¦é‡è½½æˆè¿™æ ·ï¼ˆä¸Šé¢çš„sumå˜æˆæ­¤å¤„çš„xï¼‰ï¼š

```cpp
struct Tag{
	int add;
	Tag(): add(0) {}
	Tag(int a) : add(a) {}
	void apply(Tag t){
		add += t.add;
	}
};

struct Info {
	int x, l, r;
	Info(): x(0), l(0), r(0) {}
	Info(int val, int a, int b) : x(val), l(a), r(b) {}
	void apply(Tag t){
		x += (r - l + 1) * t.add;
	}
};

Info operator+(const Info &a, const Info &b){
		Info c;
		c.x = a.x + b.x;
		c.l = a.l;
		c.r = b.r;
		return c;
}
```



###### queryå‡½æ•°ï¼ˆåŒºé—´æŸ¥è¯¢ï¼‰

å¯¹äº**query**å‡½æ•°ï¼Œå¯ä»¥è¿›è¡ŒåŒºé—´æŸ¥è¯¢ï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ–¹å¼

ç¬¬ä¸€ç§ï¼Œç›´æ¥æŒ‡å®šéœ€è¦æŸ¥è¯¢çš„å·¦å³åŒºé—´lï¼Œrï¼Œè¿”å›**Infoç±»å‹å˜é‡**

```cpp
LazySegmentTree<Info, Tag> lsgt(n);
Info ans = lsgt.query(l, r);
```

ç¬¬äºŒç§ï¼ŒæŒ‰ç…§å¸¸è§„çº¿æ®µæ ‘çš„queryï¼Œä¼ å…¥æ ¹ï¼Œçº¿æ®µæ ‘å·¦å³åŒºé—´ï¼Œéœ€è¦æŸ¥è¯¢çš„å·¦å³åŒºé—´lï¼Œrï¼Œè¿”å›**Infoç±»å‹å˜é‡**

```cpp
LazySegmentTree<Info, Tag> lsgt(n);
Info ans = lsgt.query(1, 1, n, l, r);
```



###### Applyå‡½æ•°ï¼ˆåŒºé—´ä¿®æ”¹ï¼‰

å¯¹äº**Apply**å‡½æ•°ï¼Œå¯ä»¥è¿›è¡ŒåŒºé—´ä¿®æ”¹ï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ–¹å¼

ç¬¬ä¸€ç§ï¼Œç›´æ¥æŒ‡å®šéœ€è¦ä¿®æ”¹çš„å·¦å³åŒºé—´lï¼Œrï¼Œä»¥åŠ**éœ€è¦æ›´æ”¹ä¸ºçš„Tagç±»å‹å˜é‡**

```cpp
LazySegmentTree<Info, Tag> lsgt(n);
lsgt.Apply(l, r, Tag_val);
```

ç¬¬äºŒç§ï¼ŒæŒ‰ç…§å¸¸è§„çº¿æ®µæ ‘æ–¹æ³•ï¼Œä¼ å…¥æ ¹ï¼Œçº¿æ®µæ ‘å·¦å³åŒºé—´ï¼Œéœ€è¦æŸ¥è¯¢çš„å·¦å³åŒºé—´lï¼Œrï¼Œä»¥åŠ**éœ€è¦æ›´æ”¹ä¸ºçš„Tagç±»å‹å˜é‡**

```cpp
LazySegmentTree<Info, Tag> lsgt(n);
lsgt.Apply(1, 1, n, l, r, Tag_val);
```



###### ä½¿ç”¨ç¤ºä¾‹

ä¾‹å¦‚ï¼Œæˆ‘éœ€è¦åŒºé—´åŠ ä»¥åŠåŒºé—´æ±‚å’Œï¼Œä¾‹é¢˜ä¸º[P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1](https://www.luogu.com.cn/problem/P3372)

```cpp
struct Tag{
	int add;
	Tag(): add(0) {}
	Tag(int a) : add(a) {}
	void apply(Tag t){
		add += t.add;
	}
};

struct Info {
	int x, l, r;
	Info(): x(0), l(0), r(0) {}
	Info(int val, int a, int b) : x(val), l(a), r(b) {}
	void apply(Tag t){
		x += (r - l + 1) * t.add;
	}
};

Info operator+(const Info &a, const Info &b){
	Info c;
		c.x = a.x + b.x;
		c.l = a.l;
		c.r = b.r;
		return c;
}

signed ICE(){
	int n, m;
	std::cin >> n >> m;
	std::vector<Info> a(n + 5);
	for(int i = 1;i <= n;i++){
		std::cin >> a[i].x;
    a[i].l = a[i].r = 1;
  }
	LazySegmentTree<Info, Tag> LSGT(n, a);
	while(m--){
		int opt, x, y, k;
		std::cin >> opt >> x >> y;
		//å½“optä¸º1æ—¶ï¼Œå¯¹åŒºé—´[x, y]å¢åŠ k
		if(opt == 1){
			std::cin >> k;
			LSGT.Apply(x, y, Tag(k));
		}else{
			//å½“optä¸º2ï¼Œæ±‚åŒºé—´[x, y]çš„å’Œ
			std::cout << LSGT.query(x, y).x << endl;
		}
	}
	return awa;
}
```



#### å¹³è¡¡æ ‘

##### Splay

> ä¾‹é¢˜ï¼š[P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘](https://www.luogu.com.cn/problem/P3369)

```cpp
class Splay{
private:
	int sz = 0, root = 0;
	std::vector<int> key, cnt, sizeT, f;
	std::vector<std::array<int, 2>> tree;

	void clear(int x){
		tree[x][0] = tree[x][1] = f[x] = cnt[x] = key[x] = sizeT[x] = 0;
	}
public:
	Splay(int n){
		key.resize(n + 5, 0);
		cnt.resize(n + 5, 0);
		sizeT.resize(n + 5, 0);
		f.resize(n + 5, 0);
		tree.resize(n + 5);
	}

	int get(int x){
		return tree[f[x]][1] == x ? 1 : 0;
	}

	void update(int x){
		if(x){
			sizeT[x] = cnt[x];
			if(tree[x][0]) sizeT[x] += sizeT[tree[x][0]];
			if(tree[x][1]) sizeT[x] += sizeT[tree[x][1]];
		}
	}

	void rotate(int x){
		int old = f[x], oldf = f[old], which = get(x);
		tree[old][which] = tree[x][which ^ 1];
		f[tree[old][which]] = old;
		f[old] = x;
		tree[x][which ^ 1] = old;
		f[x] = oldf;
		if(oldf)
			tree[oldf][tree[oldf][1] == old] = x;
		update(old);
		update(x);
	}

	void splay(int x, int goal){
		for(int fa; (fa = f[x]) != goal; rotate(x))
			if(f[fa] != goal)
				rotate(get(x) == get(fa) ? fa : x);
		if(!goal)root = x;
	}

	void insert(int x){
		if(!root){
			sz++;
			tree[sz][0] = tree[sz][1] = f[sz] = 0;
			key[sz] = x;
			cnt[sz] = 1;
			sizeT[sz] = 1;
			root = sz;
			return ;
		}
		int now = root, fa = 0;
		while(1){
			if(key[now] == x){
				cnt[now]++;
				update(now);
				update(fa);
				splay(now, 0);
				break;
			}
			fa = now;
			now = tree[now][key[now] < x];
			if(!now){
				sz++;
				tree[sz][0] = tree[sz][1] = 0;
				key[sz] = x;
				sizeT[sz] = 1;
				cnt[sz] = 1;
				f[sz] = fa;
				tree[fa][key[fa] < x] = sz;
				update(fa);
				splay(sz, 0);
				break;
			}
		}
	}

	int find(int x){
		int ans = 0, now = root;
		while(1){
			if(x < key[now])
				now = tree[now][0];
			else{
				ans += (tree[now][0] ? sizeT[tree[now][0]] : 0);
				if(x == key[now]){
					splay(now, 0);
					return ans + 1;
				}
				ans += cnt[now];
				now = tree[now][1];
			}
		}
	}

	int findx(int x){
		int now = root;
		while(true){
			if(tree[now][0] && x <= sizeT[tree[now][0]])
				now = tree[now][0];
			else{
				int tmp = (tree[now][0] ? sizeT[tree[now][0]] : 0) + cnt[now];
				if(x <= tmp)return key[now];
				x -= tmp;
				now = tree[now][1];
			}
		}
	}

	int pre(){
		int now = tree[root][0];
		while(tree[now][1])now = tree[now][1];
		return now;
	}

	int next(){
		int now = tree[root][1];
		while(tree[now][0])now = tree[now][0];
		return now; 
	}

	void del(int x){
		find(x);
		if(cnt[root] > 1){
			cnt[root]--;
			update(root);
			return ;
		}
		if(!tree[root][0] && !tree[root][1]){
			clear(root);
			root = 0;
			return ;
		}
		if(!tree[root][0]){
			int oldroot = root;
			root = tree[root][1];
			f[root] = 0;
			clear(oldroot);
			return ;
		}else if(!tree[root][1]){
			int oldroot = root;
			root = tree[root][0];
			f[root] = 0;
			clear(oldroot);
			return ;
		}
		int leftbig = pre(), oldroot = root;
		splay(leftbig, 0);
		f[tree[oldroot][1]] = root;
		tree[root][1] = tree[oldroot][1];
		clear(oldroot);
		update(root);
		return ;
	}

	int id(int x){
		int now = root;
		while(1){
			if(x == key[now])return now;
			else{
				if(x < key[now])now = tree[now][0];
				else now = tree[now][1];
			}
		}
	}

	int get_key(int x){
		return key[x];
	}
};
```

> éœ€è¦ä½¿ç”¨ï¼Œåˆ™
>
> ```cpp
> Splay splay(n);//æ­¤å¤„çš„nä¸ºæœ€å¤§å¯èƒ½çš„æ“ä½œæ¬¡æ•°
> ```
>
> è‹¥è¦å‘Mä¸­æ’å…¥ä¸€ä¸ªæ•°x
>
> ```cpp
> splay.insert(x);
> ```
>
> è‹¥è¦åˆ é™¤Mä¸­ä¸€ä¸ªæ•°å­—ï¼ˆè‹¥å¤šä¸ªç›¸åŒï¼Œåˆ™åªåˆ é™¤ä¸€ä¸ªï¼‰
>
> ```cpp
> splay.del(x);
> ```
>
> è‹¥è¦æŸ¥è¯¢Mä¸­æœ‰å¤šå°‘ä¸ªæ•°æ¯”xå°
>
> ```cpp
> splay.insert(x);
> int ans = splay.find(x);
> splay.del(x);
> ```
>
> è‹¥è¦æŸ¥è¯¢Mä»å°åˆ°å¤§æ’åºåï¼Œæ’åç¬¬xä½çš„æ•°
>
> ```cpp
> splay.findx(x);
> ```
>
> è‹¥è¦æŸ¥è¯¢Mçš„å‰é©±ï¼ˆæœ€å¤§çš„å°äºxçš„æ•°)
>
> ```cpp
> splay.insert(x);
> int pre = splay.pre();
> int ans = splay.get_key(pre);
> splay.del(x);
> ```
>
> è‹¥è¦æŸ¥è¯¢Mçš„åç»§ï¼ˆæœ€å°çš„å¤§äºxçš„æ•°ï¼‰
>
> ```cpp
> splay.insert(x);
> int next = splay.next();
> int ans = splay.get_key(next);
> splay.del(x);
> ```



#### æ ‘çŠ¶æ•°ç»„

##### æ¨¡æ¿

```cpp
#define lowbit(x) (x & (-x))
class FenwickTree{
private:
  std::vector<int> t;
  int n;
public:
  void add(int i, int val){
    while(i <= n){
      t[i] += val;
      i += lowbit(i);
    }
  }
  
  int sum(int i){
    int res = 0;
    while(i > 0){
      res += t[i];
      i -= lowbit(i);
    }
    return res;
  }
  
  FenwickTree(int x){
    n = x;
    t.resize(n + 5);
  }
};
```



##### å•ç‚¹ä¿®æ”¹ä¸åŒºé—´æ±‚å’Œ

```cpp
FenwickTree t(n);
//è¾“å…¥å¤„ç†
for(int i = 1;i <= n;i++){
  int x;
  std::cin >> x;
  t.add(i, x);
}
//å¯¹aè¿™ä¸ªç‚¹åŠ ä¸Šval
t.add(a, val);
//è¦æ±‚[a, b]çš„åŒºé—´å’Œ
int res = t.sum(b) - t.sum(a - 1);
```



##### åŒºé—´ä¿®æ”¹å’Œå•ç‚¹æ±‚å’Œ

```cpp
FenwickTree t(n);
//è¾“å…¥å¤„ç†
int last = 0;
for(int i = 1;i <= n;i++){
  int x;
  std::cin >> x;
  t.add(i, x - last);
  last = x;
}
//å¯¹[a, b]åŒºé—´éƒ½åŠ ä¸Šval
t.add(a, val);
t.add(b + 1, -val);
//æ±‚xä½ç½®çš„æ•°å­—æ˜¯å¤šå°‘
int res = t.sum(x);
```



##### ä½¿ç”¨æ ‘çŠ¶æ•°ç»„æ±‚é€†åºå¯¹

é€†åºå¯¹çš„å®šä¹‰ä¸ºï¼šå¯¹äºä»»æ„ $(i, j), \ (i < j)$ ï¼Œéƒ½æœ‰ $a[i] > a[j]$ 





#### STè¡¨

> STè¡¨æ˜¯ä¸€ç§ç”¨äºå¤„ç†é™æ€åŒºé—´å¯é‡å¤è´¡çŒ®é—®é¢˜çš„æ•°æ®ç»“æ„
>
> > å¯é‡å¤è´¡çŒ®é—®é¢˜æŒ‡çš„æ˜¯å¯¹åŒºé—´çš„æŸ¥è¯¢æ“ä½œçš„ç»“æœä¸ä¼šå› ä¸ºåŒºé—´è¢«é‡å¤è®¡ç®—äºŒæ”¹å˜
>
> é¢„å¤„ç†æ—¶é—´å¤æ‚åº¦ä¸º$O(NlogN)$ï¼ŒæŸ¥è¯¢æ—¶é—´å¤æ‚åº¦ä¸º$O(1)$
>
> ä¾‹é¢˜ï¼š[P3865 ã€æ¨¡æ¿ã€‘ST è¡¨ && RMQ é—®é¢˜](https://www.luogu.com.cn/problem/P3865)

```cpp
//æœ‰nä¸ªå…ƒç´ ï¼Œmæ¬¡æŸ¥è¯¢
int n, m;
std::cin >> n >> m;
std::vector<int> lg(n + 5);
std::vector<std::vector<int>> st(20, std::vector<int>(n + 5));
for(int i = 2;i <= n;i++)
	lg[i] = lg[i >> 1] + 1;
for(int i = 1;i <= n;i++)
	std::cin >> st[0][i];
for(int j = 1; (1ll << j) <= n; j++){
	int last = 1ll << (j - 1);
	for(int i = 1; i + (1ll << j) - 1 <= n; i++)
		st[j][i] = std::max(st[j - 1][i], st[j - 1][i + last]);
  //æ­¤å¤„åªå±•ç¤ºåŒºé—´æœ€å¤§å€¼ï¼Œè‹¥æƒ³è¦åŒºé—´æœ€å°å€¼æˆ–è€…åŒºé—´gcd
  //ç›´æ¥å°†std::maxæ”¹æˆstd::minæˆ–è€…gcdå³å¯
}
while(m--){
	int l, r;
	std::cin >> l >> r;
	int len = lg[r - l + 1];
	std::cout << std::max(st[len][l], st[len][r - (1ll << len) + 1]) << endl;
}
```



#### äºŒå‰æ ‘

äºŒå‰æ ‘æ˜¯**æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­æ ‘**çš„æ ‘ç»“æ„ï¼Œ**å¯ä»¥æ˜¯ç©ºé›†**ï¼Œæ¯ä¸ªç»“ç‚¹å¯ä»¥æœ‰å·¦å­æ ‘ï¼Œå¯ä»¥æœ‰å³å­æ ‘ï¼Œä¹Ÿå¯ä»¥æ²¡æœ‰

```cpp
struct Node{
  int val, l, r;
};
std::vector<Node> a(n + 5);
```



**äºŒå‰æ ‘çš„å‰ä¸­ååºéå†**

å‰åºéå†ï¼ˆæ ¹->å·¦->å³ï¼‰

```cpp
std::function<void(int)>pre = [&](int x) -> void{
  std::cout << a[x].val << endl;
  if(a[x].l)pre(a[x].l);
  if(a[x].r)pre(a[x].r);
};
```

ä¸­åºéå†ï¼ˆå·¦->æ ¹->å³ï¼‰

```cpp
std::function<void(int)>mid = [&](int x) -> void{
  if(a[x].l)mid(a[x].l);
  std::cout << a[x].val << endl;
  if(a[x].r)mid(a[x].r);
};
```

ååºéå†ï¼ˆå·¦->å³->æ ¹ï¼‰

```cpp
std::function<void(int)>post = [&](int x) -> void{
  if(a[x].l)post(a[x].l);
  if(a[x].r)post(a[x].r);
  std::cout << a[x].val << endl;
};
```





### åŠ¨æ€è§„åˆ’

#### èƒŒåŒ…

##### 01èƒŒåŒ…

> æ¯ä¸ªç‰©å“**åªèƒ½é€‰ä¸€æ¬¡**ï¼Œæ±‚æœ€å¤§ä»·å€¼
>
> ä¾‹é¢˜ï¼š[P1048 [NOIP 2005 æ™®åŠç»„] é‡‡è¯](https://www.luogu.com.cn/problem/P1048)

```cpp
int n, m;
std::cin >> n >> m;
//æ­¤å¤„çš„mä¸ºæœ€å¤§é‡é‡
std::vector<int> f(m + 5);
std::vector<PII> a(n + 5);
//è¿™é‡Œçš„PIIå­˜çš„æ˜¯ é‡é‡ ä»·å€¼
for(int i = 1;i <= n;i++)
	std::cin >> a[i].first >> a[i].second;
//ä»¥ä¸‹ä¸º01èƒŒåŒ…
for(int i = 1;i <= n;i++){
	auto [w, v] = a[i];
	for(int j = m;j >= w;j--)//ä»å®¹é‡å‡ºå‘ï¼Œç›´åˆ°å½“å‰ç‰©å“é‡é‡ï¼Œé€†åº
		f[j] = std::max(f[j], f[j - w] + v);
}
std::cout << f[m] << endl;
```



##### å®Œå…¨èƒŒåŒ…

> æ¯ä¸ªç‰©å“å¯ä»¥é€‰**æ— é™æ¬¡**ï¼Œæ±‚æœ€å¤§ä»·å€¼
>
> ä¾‹é¢˜ï¼š[P1616 ç–¯ç‹‚çš„é‡‡è¯](https://www.luogu.com.cn/problem/P1616)

```cpp
int n, m;
std::cin >> n >> m;
//æ­¤å¤„çš„mä¸ºæœ€å¤§é‡é‡
std::vector<int> f(m + 5);
std::vector<PII> a(n + 5);
//è¿™é‡Œçš„PIIå­˜çš„æ˜¯ é‡é‡ ä»·å€¼
for(int i = 1;i <= n;i++)
	std::cin >> a[i].first >> a[i].second;
//ä»¥ä¸‹ä¸ºå®Œå…¨èƒŒåŒ…
for(int i = 1;i <= n;i++){
	auto [w, v] = a[i];
	for(int j = w;j <= m;j++)//ä»å½“å‰ç‰©å“é‡é‡å‡ºå‘ï¼Œæ­£åº
		f[j] = std::max(f[j], f[j - w] + v);
}
std::cout << f[m] << endl;
```



##### å¤šé‡èƒŒåŒ…

> ä¾‹é¢˜:[P2347 [NOIP 1996 æé«˜ç»„] ç ç ç§°é‡](https://www.luogu.com.cn/problem/P2347)
>
> [P1776 å®ç‰©ç­›é€‰](https://www.luogu.com.cn/problem/P1776)

```cpp
//è¿™é‡Œçš„Wæ˜¯æœ€å¤§å®¹é‡
int n, W;
std::cin >> n >> W;
//PIIä¸­å­˜çš„æ˜¯ ä»·å€¼ é‡é‡
std::vector<PII> a;
std::vector<int> f(W + 5);
for(int i = 1;i <= n;i++){
	int v, w, cnt;
	std::cin >> v >> w >> cnt;
  //è¿›è¡ŒäºŒè¿›åˆ¶æ‹†åˆ†
	int k = 1;
	while(k <= cnt){
		a.push_back({v * k, w * k});
		cnt -= k;
		k *= 2;
	}
  //å¦‚æœè¿˜æœ‰å¤šçš„ä¹Ÿè¦pushè¿›å»
	if(cnt)a.push_back({v * cnt, w * cnt});
}
//æ­¤å¤„ä¸º01èƒŒåŒ…
for(auto [v, w] : a)
	for(int j = W; j >= w; j--)
		f[j] = std::max(f[j - w] + v, f[j]);
std::cout << f[W] << endl;
```



##### åˆ†ç»„èƒŒåŒ…

> ä¾‹é¢˜ï¼š[P1757 é€šå¤©ä¹‹åˆ†ç»„èƒŒåŒ…](https://www.luogu.com.cn/problem/P1757)

```cpp
int n, m;
//æœ‰nä»¶ç‰©å“ï¼Œæœ€å¤§å®¹é‡ä¸ºm
std::cin >> n >> m;
//ä½¿ç”¨mapæ˜ å°„ï¼ŒPIIå­˜çš„ä¸º é‡é‡ ä»·å€¼
std::map<int, std::vector<PII>> g;
for(int i = 1;i <= n;i++){
	int w, v, c;
  //ç¬¬iä¸ªç‰©å“æ˜¯ç¬¬cç»„çš„ï¼Œé‡é‡ä¸ºwï¼Œä»·å€¼ä¸ºv
	std::cin >> w >> v >> c;
	g[c].push_back({w, v});
}
std::vector<int> f(m + 5);
//åˆ†ç»„èƒŒåŒ…ï¼Œå…ˆæŒ‰ç…§ç»„å»å‡ºå…ƒç´ ï¼Œå†è¿›è¡Œ01èƒŒåŒ…
for(const auto &[key, a] : g)
	for(int i = m; i >= 0; i--)
		for(auto &[w, v] : a)
			if(i >= w)
				f[i] = std::max(f[i], f[i - w] + v);
std::cout << f[m] << endl;
```



##### äºŒç»´01èƒŒåŒ…

> ä¾‹é¢˜ï¼š[P1507 NASAçš„é£Ÿç‰©è®¡åˆ’](https://www.luogu.com.cn/problem/P1507)

```cpp
int a_max, b_max, n;
std::cin >> a_max >> b_max >> n;
std::vector<std::vector<int>> f(a_max + 5, std::vector<int>(b_max + 5));
for(int i = 1;i <= n;i++){
	int a, b, v;
	std::cin >> a >> b >> v;
	for(int j = a_max; j >= a; j--)
		for(int k = b_max; k >= b; k--)
			f[j][k] = std::max(f[j][k], f[j - a][k - b] + v);
}
int ans = 0;
for(int i = 0;i <= a_max;i++)
	for(int j = 0;j <= b_max;j++)
		ans = std::max(ans, f[i][j]);
std::cout << ans << endl;
```



### æ‚é¡¹

#### __int128çš„ä½¿ç”¨

> \_\_int128èŒƒå›´æ˜¯[$-2^{127}$ï¼Œ$2^{127}$)ï¼Œè‹¥ä½¿ç”¨unsigned \_\_int128ï¼ŒèŒƒå›´åˆ™æ˜¯[0, $2^{128}$]ï¼Œå¤§çº¦39ä½æ•°
>
> ç²¾ç¡®èŒƒå›´ï¼Œ\_\_int128çš„èŒƒå›´æ˜¯[âˆ’170141183460469231731687303715884105728, 170141183460469231731687303715884105727]
>
> unsigned \_\_int128çš„èŒƒå›´æ˜¯[0, 340282366920938463463374607431768211455]

\_\_int128**ä¸æ”¯æŒ**cinï¼Œcoutçš„è¯»å…¥è¾“å‡ºï¼Œæ‰€ä»¥è¦æ‰‹å†™[å¿«è¯»&å¿«å†™](#fifo)ï¼Œä½†æ˜¯**æ”¯æŒ**å››åˆ™è¿ç®—ï¼Œå°†å…¶å½“æˆintä½¿ç”¨å³å¯



<span id="fifo"></span>

#### å¿«è¯»&å¿«å†™

```cpp
template<typename T>
inline T read(){
	T x = 0;
	int f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-')f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}

template<typename T>
void write(T x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
```

> è¦ä½¿ç”¨ï¼Œå¯ä»¥æ‰‹åŠ¨æŠŠTæ›´æ”¹ä¸ºè‡ªå·±éœ€è¦çš„ç±»å‹ï¼Œä¹Ÿå¯ä»¥
>
> ```cpp
> __int128 x = read<__int128>()
> write<__int128>(x);
> ```



#### éšæœºæ•°ä»¥åŠå¯¹æ‹

> å¤´æ–‡ä»¶å¯ä»¥ä½¿ç”¨
>
> ```cpp
> #include <bits/stdc++.h>
> ```
>
> ä½†å½“ä¸‡èƒ½å¤´æ–‡ä»¶ä¸èƒ½ä½¿ç”¨æ—¶ï¼Œéœ€è¦ä½¿ç”¨ä¸‹è¿°åŒæ–‡ä»¶ï¼š
>
> ```cpp
> #include <iostream>
> #include <chrono>
> #include <thread>
> #include <functional>
> #include <random>
> ```

##### éšæœºæ•°ç”Ÿæˆ

å•è°ƒæ—¶é—´æˆ³ç”Ÿæˆç§å­

```cpp
auto seed = std::chrono::steady_clock::now().time_since_epoch().count();
```

ä½¿ç”¨PIDç”Ÿæˆç§å­

```cpp
auto thread_id = std::hash<std::thread::id>{}(std::this_thread::get_id());
```

ä½¿ç”¨é«˜ç²¾åº¦æ—¶é’Ÿæ—¶é—´æˆ³

```cpp
auto time_seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
```



##### éšæœºæ•°ç”Ÿæˆä»£ç 

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define awa 0
typedef long long ll;

signed ICE(){
	static std::mt19937 gen([]{
        auto time_seed = std::chrono::steady_clock::now().time_since_epoch().count();
        auto thread_id = std::hash<std::thread::id>{}(std::this_thread::get_id());
        auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
        return seed + thread_id;
    }());
    std::uniform_int_distribution<int> dis(1, 200000);
  	//åœ¨æ­¤å¤„æ·»åŠ è¾“å‡ºæ¨¡å—
	return awa;
}

signed main(){
	std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
	int T = 1;
	//std::cin >> T;
	while(T--)ICE();
	return 0;
}
```

> å…¶ä¸­std::mt19937ä¸­çš„returnå¯ä»¥æ˜¯ä¸‰ä¸ªç§å­è‡ªç”±ç»„åˆ
>
> uniform_int_distributionä¼šäº§ç”Ÿè¿™ä¸ªåŒºé—´å†…çš„éšæœºæ•°
>
> ç”¨æ³•:
>
> ```cpp
> std::cout << dis(gen()) << endl;
> ```
>
> ä¸”ä¸Šè¿°ä»£ç åœ¨windows, macOS, linuxéƒ½å¯ä»¥ä½¿ç”¨



##### å¯¹æ‹è„šæœ¬

> å¯¹äºä¸‹è¿°è„šæœ¬ï¼Œ**xxx\_\_Generator.cppæ˜¯ç”Ÿæˆæ•°æ®çš„ï¼Œxxx\_\_Good.cppæ˜¯æš´åŠ›çš„æ­£ç¡®ä»£ç ï¼Œxxx.cppæ˜¯éœ€è¦å¯¹æ‹çš„ä»£ç **

###### Linux/MacOSï¼ˆcheck.sh)

> ä½¿ç”¨æ—¶ï¼Œè®°å¾—æ›´æ”¹ä¸‹é¢çš„æ–‡ä»¶åï¼Œæ­¤è„šæœ¬ç”¨main.cppä½œä¸ºæ ·ä¾‹
>
> æœ€åçš„ç»“æœ**ä¼šè¾“å‡ºåˆ°ç»ˆç«¯ä»¥åŠç»Ÿè®¡ç›®å½•çš„result.txt**

check.sh

```bash
#!/bin/bash

# è®°å¾—æ›´æ”¹ä¸‹é¢æ–‡ä»¶å
g++ -std=c++14 main__Generator.cpp -o generator
g++ -std=c++14 main__Good.cpp -o good
g++ -std=c++14 main.cpp -o test

> result.txt
epoch=1

while true; do
    echo "Testing epoch: $epoch"
    ./generator > input.txt
    ./good < input.txt > good.out
    ./test < input.txt > test.out
    
    if ! diff good.out test.out > /dev/null; then
        echo "WA found at epoch $epoch!" | tee -a result.txt
        {
            echo "INPUT:"
            cat input.txt
            echo "GOOD:"
            cat good.out
            echo "BAD:"
            cat test.out
        } >> result.txt
        cat result.txt
        break
    fi
    
    echo "AC"
    epoch=$((epoch+1))
done
```

> è‹¥æç¤º
>
> ```shell
> permission denied: ./check.sh
> ```
>
> åˆ™åœ¨ç»ˆç«¯ä¸­è¿è¡Œ
>
> ```shell
> chmod +x check.sh
> ```



###### Windowsï¼ˆcheck.batï¼‰

> ä½¿ç”¨æ—¶ï¼Œè®°å¾—æ›´æ”¹ä¸‹é¢çš„æ–‡ä»¶åï¼Œæ­¤è„šæœ¬ç”¨main.cppä½œä¸ºæ ·ä¾‹
>
> æœ€åçš„ç»“æœ**ä¼šè¾“å‡ºåˆ°ç»ˆç«¯ä»¥åŠç»Ÿè®¡ç›®å½•çš„result.txt**

check.bat

```bat
@echo off
setlocal enabledelayedexpansion

:: è®°å¾—æ›´æ”¹ä¸‹é¢æ–‡ä»¶å
g++ -std=c++14 main__Generator.cpp -o generator.exe
g++ -std=c++14 main__Good.cpp -o good.exe
g++ -std=c++14 main.cpp -o test.exe

type nul > result.txt
set epoch=1

:loop
echo Testing epoch: %epoch%
generator.exe > input.txt
good.exe < input.txt > good.out
test.exe < input.txt > test.out

fc /b good.out test.out >nul
if errorlevel 1 (
    echo WA found at epoch %epoch%! >> result.txt
    echo WA found at epoch %epoch%!
    echo INPUT: >> result.txt
    type input.txt >> result.txt
    echo GOOD: >> result.txt
    type good.out >> result.txt
    echo BAD: >> result.txt
    type test.out >> result.txt
    type result.txt
    exit /b
)

echo AC
set /a epoch+=1
goto loop
```



#### å‰ç¼€å’Œ

##### ä¸€ç»´æ±‚å’Œå‰ç¼€å’Œ

```cpp
std::vector<int> f(n + 5), a(n + 5);
for(int i = 1;i <= n;i++)
  std::cin >> a[i];
for(int i = 1;i <= n;i++)
  f[i] = f[i - 1] + a[i];
int l, r;
std::cin >> l >> r;
std::cout << f[r] - f[l - 1] << std::endl;
```

> ä¾‹é¢˜: [P8218 ã€æ·±è¿›1.ä¾‹1ã€‘æ±‚åŒºé—´å’Œ](https://www.luogu.com.cn/problem/P8218)

##### ä¸€ç»´å¼‚æˆ–å‰ç¼€å’Œ

```cpp
std::vector<int> f(n + 5), a(n + 5);
for(int i = 1;i <= n;i++)
  std::cin >> a[i];
for(int i = 1;i <= n;i++)
  f[i] ^= f[i - 1] ^ a[i];
int l, r;
std::cin >> l >> r;
std::cout << f[r] ^ f[l - 1] << std::endl;
```

##### äºŒç»´æ±‚å’Œå‰ç¼€å’Œ

```cpp
std::vector<std::vector<int>> f(n + 5, std::vector<int>(m + 5)), a(n + 5, std::vector<int>(m + 5));
for(int i = 1;i <= n;i++)
  for(int j = 1;j <= m;j++)
    std::cin >> a[i][j];
for(int i = 1;i <= n;i++){
  int sum = 0;
  for(int j = 1;j <= m;j++){
    sum += a[i][j];
    f[i][j] = f[i - 1][j] + sum;
  }
}
int x1, y1, x2, y2;
std::cin >> x1 >> y1 >> x2 >> y2;
std::cout << f[x2][y2] - f[x2][y1 - 1] - f[x1 - 1][y2] + f[x1 - 1][y1 - 1] << std::endl;
```

> ä¾‹é¢˜ï¼š[P1719 æœ€å¤§åŠ æƒçŸ©å½¢](https://www.luogu.com.cn/problem/P1719)



#### å·®åˆ†

##### ä¸€ç»´å·®åˆ†

```cpp
std::vector<int> d(n + 5), a(n + 5);
for(int i = 1;i <= q;i++){
  int l, r;
  std::cin >> l >> r;
  d[l]++;
  d[r + 1]--;
}
for(int i = 1;i <= n;i++)
  a[i] = a[i - 1] + d[i];
for(int i = 1;i <= n;i++)
  std::cout << a[i] << " ";
std::cout << std::endl;
```

> ä¾‹é¢˜ï¼š[P2367 è¯­æ–‡æˆç»©](https://www.luogu.com.cn/problem/P2367)

##### äºŒç»´å·®åˆ†

```cpp
std::vector<std::vector<int>> d(n + 5, std::vector<int>(n + 5)), a(n + 5, std::vector<int>(n + 5));
	for(int i = 1;i <= m;i++){
		int x1, x2, y1, y2;
		std::cin >> x1 >> y1 >> x2 >> y2;
		d[x1][y1]++;
		d[x2 + 1][y1]--;
		d[x1][y2 + 1]--;
		d[x2 + 1][y2 + 1]++;
	}
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++)
			a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + d[i][j];
	for(int i = 1;i <= n;i++){
    for(int j = 1;j <= n;j++)
      std::cout << a[i][j] << " ";
    std::cout << std::endl;
  }
```

> ä¾‹é¢˜ï¼š[P3397 åœ°æ¯¯](https://www.luogu.com.cn/problem/P3397)



#### æ»‘åŠ¨çª—å£

> ä¾‹é¢˜ï¼š[P1638 é€›ç”»å±•](https://www.luogu.com.cn/problem/P1638)
>
> æ»‘åŠ¨çª—å£æ˜¯ä¸€ç§è´ªå¿ƒæ€æƒ³ é€šè¿‡åŠ¨æ€è°ƒæ•´åŒæŒ‡é’ˆæ¥å¤„ç†é—®é¢˜ è‹¥é•¿åº¦ä¸ºn åˆ™å…¶æ—¶é—´å¤æ‚åº¦ä¸ºO(n)
>
> é¦–å…ˆå°†å³æŒ‡é’ˆä¸€ç›´åƒå³æ¨ï¼Œç›´åˆ°æ»¡è¶³æ¡ä»¶
>
> ç„¶åå·¦æŒ‡é’ˆå¾€å³æ¨ï¼Œç›´åˆ°æ¡ä»¶ä¸æ»¡è¶³
>
> é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œå³å¯æ±‚å¾—ç­”æ¡ˆ

```cpp
std::vector<int> a(n + 5);
for(int i = 1;i <= n;i++)
  std::cin >> a[i];
int l = 1, r = 1;
while(r <= n){
  //åœ¨è¿™é‡Œå¯¹å³æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ è¿›è¡Œå¤„ç†
  if(/*æ»¡è¶³æ¡ä»¶*/){
    while(l <= n && /*æ»¡è¶³æ¡ä»¶*/){
      //åˆ å»å·¦æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ 
      l++;
    }
    l--;//è¿™é‡Œl--çš„åŸå› æ˜¯ ä¸Šé¢çš„whileä¼šä½¿å¾—å…¶**æ°å¥½**ä¸æ»¡è¶³æ¡ä»¶ æ­¤æ—¶æˆ‘é€€å›ä¸€æ­¥æ“ä½œ æ­¤æ—¶çš„åŒºé—´**æ°å¥½**æ»¡è¶³æ¡ä»¶
  	//æ›´æ–°ç­”æ¡ˆ
    l++;//è¿™é‡Œå°†ä¸Šé¢çš„æ“ä½œå›æº¯
  }
  r++;
}
```



#### äºŒåˆ†

##### æ‰‹å†™äºŒåˆ†

```cpp
int l = 1, r = n, mid, ans = 0;
while(l <= r){
  mid = (l + r) >> 1;
  if(check(mid)){
    ans = mid;
    l = mid + 1;
  }else r = mid - 1;
}
```

##### STLäºŒåˆ†å†™æ³•

* lower_bound()

  ```cpp
  int x = val;//valæ˜¯ä½ éœ€è¦æ‰¾çš„å€¼
  std::vector<int> a(n + 5);
  for(int i = 1;i <= n;i++)
    std::cin >> a[i];
  std::sort(a.begin() + 1, a.begin() + 1 + n);
  int p = std::lower_bound(a.begin() + 1, a.begin() + 1 + n, x) - a.begin();
  ```

  > lower_boundé»˜è®¤æ˜¯å¯¹**éé™åºåˆ—**ä½¿ç”¨ï¼Œè¿”å›çš„æ˜¯ç¬¬ä¸€ä¸ª**å¤§äºç­‰äº**xçš„å€¼å¯¹åº”çš„**è¿­ä»£å™¨**

* upper_bound()
	```cpp
	int x = val;//valæ˜¯ä½ éœ€è¦æ‰¾çš„å€¼
	std::vector<int> a(n + 5);
  for(int i = 1;i <= n;i++)
    std::cin >> a[i];
  std::sort(a.begin() + 1, a.begin() + 1 + n);
  int p = std::upper_bound(a.begin() + 1, a.begin() + 1 + n, x) - a.begin();
  ```
  > upper_boundé»˜è®¤æ˜¯å¯¹**éé™åºåˆ—**ä½¿ç”¨ï¼Œè¿”å›çš„æ˜¯ç¬¬ä¸€ä¸ª**å¤§äº**xçš„å€¼å¯¹åº”çš„**è¿­ä»£å™¨**

#### é«˜ç²¾åº¦(TODO)

##### é«˜ç²¾åº¦åŠ æ³•

##### é«˜ç²¾åº¦å‡æ³•

##### é«˜ç²¾åº¦ä¹˜æ³•

##### é«˜ç²¾åº¦é™¤æ³•



#### STLå‡½æ•°

##### max_element

```cpp
std::vector<int> a(n + 5);
for(int i = 1;i <= n;i++)
  std::cin >> a[i];
int mx = *max_element(a.begin() + 1, a.begin() + 1 + n);
```

> max_elementæ˜¯è¿”å›[begin, end]ä¸­æœ€å¤§å…ƒç´ å¯¹åº”çš„**è¿­ä»£å™¨**



##### min_element

```cpp
std::vector<int> a(n + 5);
for(int i = 1;i <= n;i++)
  std::cin >> a[i];
int mn = *min_element(a.begin() + 1, a.begin() + 1 + n);
```

> min_elementäº‹è¿”å›[begin, end]ä¸­æœ€å°å…ƒç´ å¯¹åº”çš„**è¿­ä»£å™¨**



##### next_permutation

```cpp
std::vector<int> a(4);
a = {0, 1, 2, 3};//æ¨¡æ¿æ•°ç»„ä¸‹æ ‡ä»1å¼€å§‹ï¼Œå³â€œæœ‰æ•ˆéƒ¨åˆ†â€ä¸º{1,2,3}
do{
  for(int i = 1;i <= 3;i++)
    std::cout << a[i] << " ";
  std::cout << std::endl;
}while(next_permutation(a.begin() + 1, a.begin() + 1 + 3));
```

> next_permutationæ±‚çš„æ˜¯[begin, end]çš„å½“å‰æ’åˆ—çš„**ä¸‹ä¸€ä¸ªæ’åˆ—**ï¼Œè‹¥å½“å‰æ’åˆ—**ä¸å­˜åœ¨**ä¸‹ä¸€ä¸ªæ’åˆ—ï¼Œåˆ™è¿”å›**false**ï¼Œå¦åˆ™è¿”å›**true**



##### prev_permutation

```cpp
std::vector<int> a(4);
a = {0, 3, 2, 1};//æ¨¡æ¿æ•°ç»„ä¸‹æ ‡ä»1å¼€å§‹ï¼Œå³â€œæœ‰æ•ˆéƒ¨åˆ†â€ä¸º{3,2,1}
do{
  for(int i = 1;i <= 3;i++)
    std::cout << a[i] << " ";
  std::cout << std::endl;
}while(prev_permutation(a.begin() + 1, a.begin() + 1 + 3));
```

> prev_permutationæ±‚çš„æ˜¯[begin, end]çš„å½“å‰æ’åˆ—çš„**ä¸Šä¸€ä¸ªæ’åˆ—**ï¼Œè‹¥å½“å‰æ’åˆ—**ä¸å­˜åœ¨**ä¸Šä¸€ä¸ªæ’åˆ—ï¼Œåˆ™è¿”å›**false**ï¼Œå¦åˆ™è¿”å›**true**



##### greater

> å¯¹äº**æ•°ç»„** è‹¥**ä»å·¦åˆ°å³éå†ä¸‹è¡¨æ—¶** å˜æˆ**é™åº** å³**ä»å¤§åˆ°å°**
>
> å¯¹äº**å»ºå †æ—¶** å˜æˆ**å¤§æ ¹å †** å³**ä»ä¸‹å±‚åˆ°ä¸Šå±‚** å †å…ƒç´ **ä»å¤§åˆ°å°**



##### less

> å¯¹äº**æ•°ç»„** è‹¥**ä»å·¦åˆ°å³éå†ä¸‹è¡¨æ—¶** å˜æˆ**å‡åº** å³**ä»å°åˆ°å¤§**
>
> å¯¹äº**å»ºå †æ—¶** å˜æˆ**å°æ ¹å †** å³**ä»ä¸‹å±‚åˆ°ä¸Šå±‚** å †å…ƒç´ **ä»å°åˆ°å¤§**



##### unique

```cpp
std::vector<int> a{0, 1, 1, 2, 2, 3, 3, 4};
std::sort(a.begin() + 1, a.begin() + 1 + 7);
a.erase(std::unique(a.begin() + 1, a.begin() + 1 + 7), a.end());
```

> è‹¥**åŸæ•°ç»„æ— åº**ï¼Œ**ä¸€å®šè¦å…ˆæ’åº**
>
> uniqueå‡½æ•°**å¹¶ä¸æ˜¯ç§»é™¤**é‡å¤å…ƒç´ ï¼Œè€Œæ˜¯å°†é‡å¤å…ƒç´ **ç½®äºæ•°ç»„æœ«å°¾**ï¼Œå¹¶ä¸”è¿”å›**å»é‡åçš„æœ«å°¾å…ƒç´ æŒ‡é’ˆ**



##### reverse

```cpp
std::vector<int> a(n + 5);
for(int i = 1;i <= n;i++)
  std::cin >> a[i];
std::reverse(a.begin() + 1, a.begin() + 1 + n);
```

> reverseæ˜¯å°†[begin, end]çš„å…ƒç´ å€’è¿‡æ¥



##### shuffle

```cpp
//éšæœºæ•°ç”Ÿæˆ
std::mt19937 gen([]{
  auto time_seed = std::chrono::steady_clock::now().time_since_epoch().count();
  auto thread_id = std::hash<std::thread::id>{}(std::this_thread::get_id());        
  auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count(); 
  return seed + time_seed + thread_id;    
}()); 
//æŠŠ[1, n]çš„aæ•°ç»„éšæœºæ‰“ä¹±
std::shuffle(a.begin() + 1, a.begin() + 1 + n, gen);
```



#### STL

##### vector

###### vectorçš„åˆå§‹åŒ–

|                       ä»£ç                        |                  æ„ä¹‰                  |
| :----------------------------------------------: | :------------------------------------: |
|                  vector\<T\> v1                  |     v1æ˜¯ä¸€ä¸ªå…ƒç´ ç±»å‹ä¸ºTçš„ç©ºvector      |
|                vector\<T\> v2(v1)                |        ä½¿ç”¨v1ä¸­æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–v2        |
|                vector\<T\> v2=v1                 |                  åŒä¸Š                  |
|              vector\<T\> v3(n, val)              |       v3ä¸­åŒ…å«äº†nä¸ªå€¼ä¸ºvalçš„å…ƒç´        |
|                vector\<T\> v4(n)                 |    v4å¤§å°ä¸ºnï¼Œæ‰€æœ‰å…ƒç´ é»˜è®¤åˆå§‹åŒ–ä¸º0    |
|             vector\<T\> v5{a, b, c}              |           ä½¿ç”¨a,b,cåˆå§‹åŒ–v5            |
| vector\<vector\<T\>\> v6(n, vector\<T\>(m, val)) | åˆå§‹åŒ–ä¸€ä¸ªn*må¤§å°ï¼Œå€¼ä¸ºvalçš„äºŒç»´çŸ©é˜µv6 |

###### vectorå¸¸ç”¨åŸºç¡€æ“ä½œ

|     ä»£ç       |                             æ„ä¹‰                             |
| :-----------: | :----------------------------------------------------------: |
|   v.empty()   |          å¦‚æœvä¸ºç©ºåˆ™è¿”å›**true**,å¦åˆ™è¿”å›**false**           |
|   v.size()    |                      è¿”å›vä¸­å…ƒç´ çš„ä¸ªæ•°                       |
|   v1 == v2    | **å½“ä¸”ä»…å½“**æ‹¥æœ‰**ç›¸åŒæ•°é‡**ä¸”**ç›¸åŒä½ç½®ä¸Šå€¼ç›¸åŒ**çš„å…ƒç´ æ—¶è¿”å›true |
|   v1 != v2    |                                                              |
| <, <=, >, >=  |                     ä»¥**å­—å…¸åº**è¿›è¡Œæ¯”è¾ƒ                     |
| v.push_back() |            å°†æŸä¸ªå…ƒç´ æ·»åŠ åˆ°våé¢ï¼Œå¹¶ä¸”å°†å…¶å¤§å°+1             |
| v.resize(val) |                  å°†vçš„å¤§å°resizeæˆvalçš„å¤§å°                  |
|   v.begin()   |            è¿”å›æŒ‡å‘å®¹å™¨**ç¬¬ä¸€ä¸ªå…ƒç´ **çš„**è¿­ä»£å™¨**            |
|    v.end()    |      è¿”å›æŒ‡å‘å®¹å™¨**å°¾ç«¯ï¼ˆéæœ€åä¸€ä¸ªå…ƒç´ ï¼‰**çš„**è¿­ä»£å™¨**      |
|  v.rbegin()   |         è¿”å›æŒ‡å‘å®¹å™¨**æœ€åä¸€ä¸ªå…ƒç´ **çš„**é€†å‘è¿­ä»£å™¨**         |
|   v.rend()    |     è¿”å›æŒ‡å‘å®¹å™¨**å‰ç«¯ï¼ˆéç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰**çš„**é€†å‘è¿­ä»£å™¨**     |

##### stack

> æ ˆæ»¡è¶³**å…ˆè¿›åå‡ºï¼ˆFILOï¼‰**åŸåˆ™

|     ä»£ç      |               æ„ä¹‰                |
| :----------: | :-------------------------------: |
| stack\<T\> s |        åˆ›å»ºä¸€ä¸ªç±»å‹ä¸ºTçš„æ ˆ        |
| s.push(val)  |           å°†valå‹å…¥æ ˆé¡¶           |
|   s.top()    |           è¿”å›æ ˆé¡¶å…ƒç´             |
|   s.pop()    |           å¼¹å‡ºæ ˆé¡¶å…ƒç´             |
|   s.size()   |           è¿”å›æ ˆçš„å¤§å°            |
|  s.empty()   | è‹¥æ ˆç©ºï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false |

##### array

|           ä»£ç            |                         æ„ä¹‰                         |
| :----------------------: | :--------------------------------------------------: |
|    array\<T, val\> a0    |         åˆå§‹åŒ–ä¸€ä¸ªå¤§å°ä¸ºvalï¼Œç±»å‹ä¸ºTçš„æ•°ç»„a0         |
| array\<T, 3\> a1={1,2,3} |              ç”¨{1,2,3}åˆå§‹åŒ–a1ï¼Œç±»å‹ä¸ºT              |
| array\<T, val\> a2 = a0  |                     ç”¨a0åˆå§‹åŒ–a2                     |
|        a.begin()         |        è¿”å›æŒ‡å‘å®¹å™¨**ç¬¬ä¸€ä¸ªå…ƒç´ **çš„**è¿­ä»£å™¨**        |
|         a.end()          |  è¿”å›æŒ‡å‘å®¹å™¨**å°¾ç«¯ï¼ˆéæœ€åä¸€ä¸ªå…ƒç´ ï¼‰**çš„**è¿­ä»£å™¨**  |
|        a.rbegin()        |     è¿”å›æŒ‡å‘å®¹å™¨**æœ€åä¸€ä¸ªå…ƒç´ **çš„**é€†å‘è¿­ä»£å™¨**     |
|         a.rend()         | è¿”å›æŒ‡å‘å®¹å™¨**å‰ç«¯ï¼ˆéç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰**çš„**é€†å‘è¿­ä»£å™¨** |

##### set

> setå†…éƒ¨å°è£…äº†çº¢é»‘æ ‘ é»˜è®¤æ˜¯**æœ‰æ’åºä¸”ä»å°åˆ°å¤§æ’åº**çš„ ä¸”setä¸­**å…ƒç´ å€¼ä¸é‡å¤**

|        ä»£ç         |                             æ„ä¹‰                             |
| :----------------: | :----------------------------------------------------------: |
|     set\<T\> s     |                     åˆå§‹åŒ–ä¸€ä¸ªç±»å‹Tçš„set                     |
|     s.clear()      |                      åˆ é™¤sä¸­çš„æ‰€æœ‰å…ƒç´                        |
|     s.empty()      |             è‹¥setä¸ºç©ºï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false             |
|   s.insert(val)    |                         å°†valæ’å…¥set                         |
|    s.erase(it)     |                 å°†**è¿­ä»£å™¨it**æŒ‡å‘çš„å…ƒç´ åˆ æ‰                 |
|    s.erase(key)    |                   å°†**å€¼ä¸ºkey**çš„å…ƒç´ åˆ æ‰                    |
|    s.find(val)     | æŸ¥æ‰¾**å€¼ä¸ºval**çš„å…ƒç´ ï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„**è¿­ä»£å™¨**ï¼Œè‹¥**æ²¡æ‰¾åˆ°åˆ™è¿”å›end()** |
| s.lower_bound(val) |       è¿”å›ç¬¬ä¸€ä¸ª**å¤§äºç­‰äºval**çš„å…ƒç´ å¯¹åº”çš„**è¿­ä»£å™¨**        |
| s.upper_bound(val) |         è¿”å›ç¬¬ä¸€ä¸ª**å¤§äºval**çš„å…ƒç´ å¯¹åº”çš„**è¿­ä»£å™¨**          |
|     s.begin()      |            è¿”å›æŒ‡å‘å®¹å™¨**ç¬¬ä¸€ä¸ªå…ƒç´ **çš„**è¿­ä»£å™¨**            |
|      s.end()       |      è¿”å›æŒ‡å‘å®¹å™¨**å°¾ç«¯ï¼ˆéæœ€åä¸€ä¸ªå…ƒç´ ï¼‰**çš„**è¿­ä»£å™¨**      |
|     s.rbegin()     |         è¿”å›æŒ‡å‘å®¹å™¨**æœ€åä¸€ä¸ªå…ƒç´ **çš„**é€†å‘è¿­ä»£å™¨**         |
|      s.rend()      |     è¿”å›æŒ‡å‘å®¹å™¨**å‰ç«¯ï¼ˆéç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰**çš„**é€†å‘è¿­ä»£å™¨**     |

<span id="set_rewrite_sort_rule"></span>

###### seté‡å†™æ’åºè§„åˆ™

> æƒ³è¦å®ç°è‡ªå®šä¹‰ç±»å‹çš„å…ƒç´ æ’åºè§„åˆ™é‡å†™ï¼Œä¾‹å¦‚pairæˆ–è€…vectorï¼Œåªéœ€è¦å°†ä»£ç é‡Œçš„intæ”¹ä¸ºå¯¹åº”ç±»å‹å³å¯

ç¬¬ä¸€ç§æ–¹æ³•ï¼ˆæ™®é€šå‡½æ•°æŒ‡é’ˆï¼‰

```cpp
bool cmp(const int &x, const int &y){
  return x > y;
}
std::set<int, bool(*)(const int &x, const int &y)> a(cmp);
```

ç¬¬äºŒç§æ–¹æ³•ï¼ˆä»¿å‡½æ•°ï¼‰

```cpp
class cmp{
public:
	bool operator()(int x, int y) const {
    return x > y;
  }  
};
std::set<int, cmp> a;
```

ç¬¬ä¸‰ç§æ–¹æ³•ï¼ˆåº“å‡½æ•°ï¼‰

```cpp
std::set<int, std::greater<int>> a;//greateræ˜¯ä»å¤§åˆ°å°æ’åº
```

##### multiset

> multisetå†…éƒ¨åŒæ ·å°è£…äº†çº¢é»‘æ ‘ é»˜è®¤æ˜¯**æœ‰æ’åºä¸”ä»å°åˆ°å¤§æ’åº**çš„ ä½†multiset**å…è®¸å…ƒç´ å€¼é‡å¤**
>
> è‹¥æƒ³é€šè¿‡**keyå€¼**åˆ é™¤multisetçš„å…ƒç´ ï¼Œåˆ™éœ€è¦ä½¿ç”¨**s.erase(s.find(val))**

|        ä»£ç         |                             æ„ä¹‰                             |
| :----------------: | :----------------------------------------------------------: |
|  multiset\<T\> s   |                 åˆå§‹åŒ–ä¸€ä¸ªç±»å‹ä¸ºTçš„multiset                  |
|     s.clear()      |                      åˆ é™¤sä¸­çš„æ‰€æœ‰å…ƒç´                        |
|     s.empty()      |          è‹¥multisetä¸ºç©ºï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false           |
|   s.insert(val)    |                      å°†valæ’å…¥multiset                       |
|    s.erase(it)     |                 å°†**è¿­ä»£å™¨it**æŒ‡å‘çš„å…ƒç´ åˆ æ‰                 |
|    s.find(val)     | æŸ¥æ‰¾**å€¼ä¸ºval**çš„å…ƒç´ ï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„**è¿­ä»£å™¨**ï¼Œè‹¥**æ²¡æ‰¾åˆ°åˆ™è¿”å›end()** |
| s.lower_bound(val) |       è¿”å›ç¬¬ä¸€ä¸ª**å¤§äºç­‰äºval**çš„å…ƒç´ å¯¹åº”çš„**è¿­ä»£å™¨**        |
| s.upper_bound(val) |         è¿”å›ç¬¬ä¸€ä¸ª**å¤§äºval**çš„å…ƒç´ å¯¹åº”çš„**è¿­ä»£å™¨**          |
|     s.begin()      |            è¿”å›æŒ‡å‘å®¹å™¨**ç¬¬ä¸€ä¸ªå…ƒç´ **çš„**è¿­ä»£å™¨**            |
|      s.end()       |      è¿”å›æŒ‡å‘å®¹å™¨**å°¾ç«¯ï¼ˆéæœ€åä¸€ä¸ªå…ƒç´ ï¼‰**çš„**è¿­ä»£å™¨**      |
|     s.rbegin()     |         è¿”å›æŒ‡å‘å®¹å™¨**æœ€åä¸€ä¸ªå…ƒç´ **çš„**é€†å‘è¿­ä»£å™¨**         |
|      s.rend()      |     è¿”å›æŒ‡å‘å®¹å™¨**å‰ç«¯ï¼ˆéç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰**çš„**é€†å‘è¿­ä»£å™¨**     |

###### multiseté‡å†™æ’åºè§„åˆ™

è§[seté‡å†™æ’åºè§„åˆ™](#set_rewrite_sort_rule)

##### map

> mapå®¹å™¨çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª**pair**ç±»å‹çš„æ•°æ®

|        ä»£ç         |                             æ„ä¹‰                             |
| :----------------: | :----------------------------------------------------------: |
|  map\<T1, T2\> a   |               åˆå§‹åŒ–ä¸€ä¸ªç±»å‹T1æ˜ å°„åˆ°T2çš„map a                |
|     a.clear()      |                         åˆ é™¤æ‰€æœ‰å…ƒç´                          |
|    a.erase(val)    |                    åˆ é™¤**keyä¸ºval**çš„å…ƒç´                     |
|    a.erase(it)     |                  åˆ é™¤**è¿­ä»£å™¨it**å¯¹åº”çš„å…ƒç´                   |
|    a.find(val)     | æŸ¥æ‰¾**å€¼ä¸ºval**çš„å…ƒç´ ï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„**è¿­ä»£å™¨**ï¼Œè‹¥**æ²¡æ‰¾åˆ°åˆ™è¿”å›end()** |
|     a.empty()      |             è‹¥mapä¸ºç©ºï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false             |
|    a.count(val)    |     è¿”å›**keyä¸ºval**æ˜¯å¦å­˜åœ¨äºmapï¼Œè‹¥å­˜åœ¨åˆ™ä¸º1ï¼Œå¦åˆ™ä¸º0      |
| a.lower_bound(val) |      è¿”å›ç¬¬ä¸€ä¸ª**å¤§äºç­‰äº**keyçš„é”®å€¼å¯¹å¯¹åº”çš„**è¿­ä»£å™¨**       |
| a.upper_bound(val) |        è¿”å›ç¬¬ä¸€ä¸ª**å¤§äº**keyçš„é”®å€¼å¯¹å¯¹åº”çš„**è¿­ä»£å™¨**         |

> å¯¹äºmapçš„lower_boundçš„ç”¨æ³•ä¾‹å­
>
> ```cpp
> std::map<int, int> a;
> //æ­¤å¤„å¯¹aè¿›è¡Œå¤„ç†
> auto it = a.lower_bound(3);
> if(it != a.end()){
>   auto [key, value] = *it;
>   std::cout << key << " " << value << endl;
> }
> ```
>
> ä¸€èˆ¬åˆ¤æ–­mapä¸­æŸä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œ**ä¸ç”¨if(a[val])**ï¼Œè€Œæ˜¯ç”¨**if(!a.count())**
>
> å› ä¸ºå‰è€…ä¼šåˆ›å»ºä¸€ä¸ªvalçš„æ˜ å°„ï¼Œåè€…å¹¶ä¸ä¼š
>
> ä¾‹å¦‚æˆ‘bfsçš„æ—¶å€™ï¼Œéœ€è¦åˆ¤æ–­valæ˜¯å¦è¢«èµ°è¿‡ï¼Œä¸€èˆ¬ä¸ç”¨
>
> ```cpp
> std::map<int, int> vis;
> if(!vis[val])
> q.push(val);
> ```
>
> è€Œæ˜¯ä½¿ç”¨
>
> ```cpp
> if(vis.count(val) && !vis[val])
> q.push(val)
> ```
>
> è¿™æ ·ï¼Œå½“æˆ‘ä¸‹é¢ä»£ç éœ€è¦åˆ¤æ–­valæ˜¯å¦å­˜åœ¨æ—¶ï¼Œå°±ä¸ä¼šå‡ºé”™ï¼ˆå› ä¸ºå¦‚æœæˆ‘ç”¨äº†å‰è€…ï¼Œå¾ˆå¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ª(val, 0)çš„æ˜ å°„ï¼Œå½±å“ä¸‹é¢çš„åˆ¤æ–­ï¼‰

###### mapé‡å†™æ’åºè§„åˆ™

ç¬¬ä¸€ç§æ–¹æ³•ï¼ˆåº“å‡½æ•°ï¼‰

```cpp
std::map<int, int, std::greater<int>> a;//è¿™æ ·èƒ½è®©mapä»¥keyä¸ºå…³é”®è¯ä»å¤§åˆ°å°æ’åº
```

ç¬¬äºŒç§æ–¹æ³•ï¼ˆä»¿å‡½æ•°ï¼‰

```cpp
class cmp{
public:
  bool operator()(int x, int y) const {
    return x > y;
  }
};
std::map<int, int, cmp> a;
```

è‹¥è¦ä»¥**value**ä½œä¸ºå…³é”®è¯æ’åº

> **ä¸èƒ½**ä½¿ç”¨stlçš„sortå‡½æ•°ï¼Œå› ä¸ºsortå‡½æ•°åªèƒ½å¯¹**çº¿æ€§**å®¹å™¨è¿›è¡Œæ’åºï¼Œè€Œmapæ˜¯**é›†åˆå®¹å™¨**ï¼Œå­˜å‚¨çš„æ˜¯pairä¸”éçº¿å½¢å­˜å‚¨ï¼Œåˆ™åªèƒ½å°†å…¶æ”¾åˆ°vectoré‡Œåæ’åº

```cpp
std::map<int, int> vis;
//æ­¤å¤„å¯¹mapè¿›è¡Œäº†æ“ä½œ
std::vector<PII> a(vis.begin(), vis.end());
std::sort(a.begin(), a.end(). [&](const PII &x, const PII &y) -> bool{
  return x.second < y.second;
});//æ­¤å¤„æ˜¯ä»å°åˆ°å¤§æ’åº
for(auto [key, value] : a)
  std::cout << key << " " << value << endl;
```

##### queue

> é˜Ÿåˆ—æ»¡è¶³**å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰**åŸåˆ™

|     ä»£ç      |                æ„ä¹‰                 |
| :----------: | :---------------------------------: |
| queue\<T\> q |       åˆ›å»ºä¸€ä¸ªç±»å‹ä¸ºTçš„é˜Ÿåˆ—q        |
| q.push(val)  |        åœ¨é˜Ÿå°¾æ’å…¥ä¸€ä¸ªå…ƒç´ val        |
|   q.pop()    |         åˆ é™¤é˜Ÿåˆ—ç¬¬ä¸€ä¸ªå…ƒç´           |
|   q.size()   |         è¿”å›é˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°          |
|  q.empty()   | è‹¥é˜Ÿåˆ—ä¸ºç©ºåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false |

##### priority_queue

|                           ä»£ç                            |                     æ„ä¹‰                     |
| :------------------------------------------------------: | :------------------------------------------: |
| priority_queue<T, std::vector\<T\>, std::greater\<T\>> q | åˆ›å»ºä¸€ä¸ªç±»å‹ä¸ºTï¼Œ**ä»å°åˆ°å¤§**æ’åºçš„ä¼˜å…ˆé˜Ÿåˆ—q |
|  priority_queue<T, std::vector\<T\>, std::less\<T\>> q   | åˆ›å»ºä¸€ä¸ªç±»å‹ä¸ºTï¼Œ**ä»å¤§åˆ°å°**æ’åºçš„ä¼˜å…ˆé˜Ÿåˆ—q |
|                       q.push(val)                        |      å°†**å€¼ä¸ºval**çš„å…ƒç´ æ’å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­       |
|                         q.top()                          |        è¿”å›ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æœ€é«˜ä¼˜å…ˆçº§å…ƒç´         |
|                         q.pop()                          |        åˆ é™¤ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æœ€é«˜ä¼˜å…ˆçº§å…ƒç´         |
|                        q.empty()                         |   è‹¥ä¼˜å…ˆé˜Ÿåˆ—ä¸ºç©ºåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false    |
|                         q.size()                         |           è¿”å›ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°           |

##### deque

|                  ä»£ç                   |                         æ„ä¹‰                         |
| :------------------------------------: | :--------------------------------------------------: |
|              deque\<T\> q              |                  åˆ›å»ºä¸€ä¸ªåŒå‘é˜Ÿåˆ—q                   |
|  q.emplace_back(val)/q.push_back(val)  |             åœ¨é˜Ÿåˆ—å°¾éƒ¨æ’å…¥å€¼ä¸ºvalçš„å…ƒç´               |
| q.emplace_front(val)/q.push_front(val) |             åœ¨é˜Ÿåˆ—å¤´éƒ¨æ’å…¥å€¼ä¸ºvalçš„å…ƒç´               |
|              q.pop_back()              |                   åˆ é™¤é˜Ÿåˆ—å°¾éƒ¨å…ƒç´                    |
|             q.pop_front()              |                   åˆ é™¤é˜Ÿåˆ—å¤´éƒ¨å…ƒç´                    |
|               q.begin()                |        è¿”å›æŒ‡å‘å®¹å™¨**ç¬¬ä¸€ä¸ªå…ƒç´ **çš„**è¿­ä»£å™¨**        |
|                q.end()                 |  è¿”å›æŒ‡å‘å®¹å™¨**å°¾ç«¯ï¼ˆéæœ€åä¸€ä¸ªå…ƒç´ ï¼‰**çš„**è¿­ä»£å™¨**  |
|               q.rbegin()               |     è¿”å›æŒ‡å‘å®¹å™¨**æœ€åä¸€ä¸ªå…ƒç´ **çš„**é€†å‘è¿­ä»£å™¨**     |
|                q.rend()                | è¿”å›æŒ‡å‘å®¹å™¨**å‰ç«¯ï¼ˆéç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰**çš„**é€†å‘è¿­ä»£å™¨** |
|                q.size()                |                è¿”å›åŒç«¯é˜Ÿåˆ—çš„å…ƒç´ ä¸ªæ•°                |
|               q.empty()                |      è‹¥åŒç«¯é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false       |
|               q.clear()                |                       æ¸…ç©ºé˜Ÿåˆ—                       |

##### list

|       ä»£ç         |                             æ„ä¹‰                             |
| :---------------: | :----------------------------------------------------------: |
|    list\<T\> a    |                    åˆ›å»ºä¸€ä¸ªç±»å‹ä¸ºTçš„åˆ—è¡¨a                    |
| a.push_front(val) |                  å‘açš„å¤´éƒ¨æ·»åŠ å€¼ä¸ºvalçš„å…ƒç´                   |
| a.push_back(val)  |                  å‘açš„å°¾éƒ¨æ·»åŠ å€¼ä¸ºvalçš„å…ƒç´                   |
|   a.pop_front()   |                      å°†aå¤´éƒ¨çš„å…ƒç´ åˆ å»                       |
|   a.pop_back()    |                      å°†aå°¾éƒ¨çš„å…ƒç´ åˆ å»                       |
|     a.size()      |                      è¿”å›åˆ—è¡¨å…ƒç´ çš„ä¸ªæ•°                      |
|     a.begin()     |                è¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ çš„**è¿­ä»£å™¨**                |
|      a.end()      |        è¿”å›æŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ **ä¸‹ä¸€ä¸ªä½ç½®**çš„**è¿­ä»£å™¨**        |
|    a.rbegin()     |               è¿”å›æŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ çš„**è¿­ä»£å™¨**               |
|     a.rend()      |         è¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ **å‰ä¸€ä¸ªä½ç½®**çš„**è¿­ä»£å™¨**         |
|     a.sort()      | å°†æ‰€æœ‰å…ƒç´ ä»å°åˆ°å¤§æ’åºï¼Œå¯ä»¥å¡«å…¥std::greater\<T\>æ¥ä»å¤§åˆ°å°æ’åº |
|   a.remove(val)   |                      åˆ é™¤å€¼ä¸ºvalçš„å…ƒç´                        |
| a.remove_if(func) |                    è‹¥å…ƒç´ æ»¡è¶³funcï¼Œåˆ™åˆ é™¤                    |
|    a.reverse()    |                  å°†å…ƒç´ æŒ‰åŸæ¥ç›¸åçš„é¡ºåºæ’åº                  |

> æ³¨æ„ï¼Œlist**æ²¡æœ‰æä¾›[]**



### ç«èµ›å‰ç»™è‡ªå·±çš„ä¸€äº›æç¤º

1. è‹¥æ˜¯å‘ç°é¢˜ç›®**ç‰¹åˆ«å¤æ‚**ï¼Œ**æ€ä¹ˆåšä¹Ÿåšä¸å‡ºæ¥**ï¼Œä½†æ˜¯**å¾ˆå¤šäººéƒ½è¿‡äº†**ï¼Œé‚£è¦æƒ³ä¸€ä¸‹æ˜¯ä¸æ˜¯**è¯»é”™é¢˜äº†**ï¼Œ**é‡è¯»é¢˜å»**ï¼ï¼ï¼
2. **switch caseè®°å¾—è‹¥ä¼ å…¥int**ï¼Œä¸è¦å†™ç±»ä¼¼è¿™æ ·çš„ï¼š**case '3'**ï¼Œè€Œæ˜¯**case 3**ï¼ï¼ï¼ï¼ˆå°½é‡åˆ«ç”¨switch caseï¼‰
3. è‹¥æ˜¯æ­»å¾ªç¯ï¼Œè®°å¾—çœ‹çœ‹**è¾“å…¥çš„ $n$ å’Œ $m$ æœ‰æ²¡æœ‰å**ï¼ï¼é“¾å¼å‰å‘æ˜Ÿå»ºåå‘è¾¹çš„æ—¶å€™ï¼Œæœ‰æ²¡æœ‰**æé”™é¡ºåºï¼ˆä¾‹å¦‚ $(v, u)$ å†™æˆ $(u, v)$ **ï¼ï¼
4. è®°å¾—çœ‹æ•°ç»„çš„å¤§å°ç©¶ç«Ÿæ˜¯ $n$ **+ 5 **è¿˜æ˜¯ $m$ **+ 5**ï¼ï¼ï¼é˜²æ­¢MLE
5. é“¾å¼å‰å‘æ˜Ÿå»ºè¾¹çš„æ—¶å€™ï¼Œ**è‹¥éœ€è¦å»ºåŒå‘è¾¹**ï¼Œ**è®°å¾—ç©ºé—´å¼€ä¸¤å€ï¼ˆ2\*m+5)**
6. å‡ºä¸äº†é¢˜çš„æ—¶å€™ï¼Œè®°å¾—æŠŠé¢˜éƒ½çœ‹çœ‹ï¼Œé˜²æ­¢**æ¦œè¢«å¸¦æ­ª**ï¼ï¼ï¼ï¼
7. **æ³¨æ„ç‰¹åˆ¤**ï¼ï¼ï¼
8. ä¸ä¼šçš„æ„é€ æˆ–è€…æ€ç»´é¢˜ï¼Œå¯ä»¥**æš´åŠ›æ‰¾è§„å¾‹ æˆ–è€…ç›´æ¥è§‚å¯Ÿæ ·ä¾‹æ‰¾è§„å¾‹**ï¼ï¼ï¼



### TODO

æ‚é¡¹

æ¨¡æ‹Ÿé€€ç«

é€†åºå¯¹



Betaç‰ˆæœ¬å¾…æ·»åŠ 

æ•°æ®ç»“æ„

åŠ æƒå¹¶æŸ¥é›†

ç§ç±»å¹¶æŸ¥é›†

å¯æŒä¹…åŒ–å¹¶æŸ¥é›†

å¯æ’¤é”€å¹¶æŸ¥é›†



å›¾è®º

å°è£…ç½‘ç»œæµæ¨¡æ¿ï¼ˆDinicï¼ŒEKï¼‰

æ–œäºŒè¿›åˆ¶æ³•æ±‚LCA

DFNæ±‚LCA

äºŒåˆ†å›¾å¤šé‡åŒ¹é…

Bellman-Ford

æœ€å°å‰²



æ•°è®º

åšå¼ˆè®º



æ•°æ®ç»“æ„

splayçš„åŸç†ï¼Œ[P3391 ã€æ¨¡æ¿ã€‘æ–‡è‰ºå¹³è¡¡æ ‘](https://www.luogu.com.cn/problem/P3391)



æ‚é¡¹

é«˜ç²¾åº¦åŠ å‡ä¹˜é™¤æ¨¡æ¿

æ‚¬çº¿æ³•

è«é˜Ÿ

ä½è¿ç®—

é‡è½½è¿ç®—ç¬¦



è®¡ç®—å‡ ä½•



å­—ç¬¦ä¸²

ACè‡ªåŠ¨æœº

åç¼€è‡ªåŠ¨æœº

å­—å…¸æ ‘



æ‰€æœ‰æ¨¡æ¿çš„æ•™ç¨‹

